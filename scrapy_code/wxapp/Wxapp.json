{"content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量", "author": "Rolan", "pub_time": "2020-2-6 00:52", "title": "微信小程序开发中 var that =this的用法 "}
{"content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信小程序没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了 数据缓存 Storage 和 网络 Network 这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以 在这里 找到，阅读本文时配合实践，效果更佳。二、浏览器中的cookie为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：本地存储：浏览器会在本地分配一块空间，存储cookie请求携带：每次发起请求，都会从本地取出cookie并追加在请求头上响应设置：当响应头有Set-Cookie字段时，需要解析并更新过期时间：每个cookie字段有单独的过期时间，并且到期会自动清除读写操作：暴露API给前端JS调用，可进行增删改查操作作用域：路径path、域名domin编码：cookie值，在网络传输需要encode，建议存储也一样其它：HttpOnly、Secure、SameSite在浏览器的 DevTools 中，可以看到当前站点下的Cookie明细：三、小程序中的cookie实现方案设计在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。本地存储小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的 LocalStorage ），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个 cookies 字段进行存储：// 存：\r\nwx.setStorageSync('cookies', cookies)\r\n// 取：\r\nwx.getStorageSync('cookies')\r\n复制代码其中 cookies 的「存储结构」如下：// cookies = \r\n{\r\n    cookie1: { // “最小cookie单元” ==> cookieItem\r\n        name: 'cookie1', // cookie名\r\n        value: 'xxx',    // cookie值\r\n        expires: 'Fri, 17 Jan 2020 08:49:41 GMT' // 过期时间，使用GMT（格林威治标准时间）格式\r\n    }\r\n},\r\n复制代码上面的 cookie1 便是一个“最小cookie单元 cookieItem ”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的 Storage 选项卡，可以查看本地存储的情况：读写操作这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie———— getCookie()步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：function getCookie(name = '') {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let { value, expires } = cookies[name] || {}\r\n\r\n    return (name && expires && !isExpired(expires)) ? decodeURIComponent(cookieItem.value) : ''\r\n}\r\n复制代码2. 设置cookie———— setCookie()步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：设置单个/多个cookie直接传值/传cookieItem（Object）时间格式maxAge/expires调用示例如下：setCookie({\r\n    cookie1: 12345,\r\n    cookie2: '12345'\r\n})\r\n\r\nsetCookie({\r\n    cookie1: {\r\n        value: 12345,\r\n        maxAge: 3600 * 24  // 自定义有效期（这里示例是24小时）\r\n    },\r\n    cookie2: {\r\n        value: '12345',\r\n        expires: 'Wed, 21 Oct 2015 07:28:00 GMT' // 标准GMT格式\r\n    }\r\n})\r\n复制代码这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取 name/value/expires/maxAge ，传给格式化函数转为标准的 cookieItem ：function setCookie(cookiesParam) {\r\n    let oldCookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let newCookies = {} // 由 cookiesParam 转化为标准格式后的cookies\r\n\r\n    for (let name in cookiesParam) {\r\n        if (isObject(cookiesParam[name])) { // 传入是Object格式\r\n            let { value, expires, maxAge } = cookiesParam[name]\r\n            // 转换为标准cookie格式（cookieItem）\r\n            newCookies[name] = getStandardCookieItem({ name, value, expires, maxAge })\r\n        } else {\r\n            newCookies[name] = getStandardCookieItem({ name, value: cookiesParam[name] })\r\n        }\r\n    }\r\n\r\n    // 同步到本地Storage\r\n    saveCookiesToStorage(Object.assign({}, oldCookies, newCookies))\r\n}\r\n复制代码3. 删除cookie———— removeCookie()步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storagefunction removeCookie(cookieName) {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n\r\n    delete cookies[cookieName]\r\n\r\n    saveCookiesToStorage(Object.assign({}, cookies))\r\n}\r\n复制代码四、Cookie 在网络中的传递本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：Set-Cookie\r\nCookie\r\nCookie\r\n以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式： HTTP 和 WebSocket ，这里以HTTP为例，先对请求api进行「封装」：function requestPro({ url, data, header, method = 'GET' }) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url,\r\n            data,\r\n            header: Object.assign({}, { 'Cookie': CookieLib.getCookiesStr() }, header), // 请求头————带上Cookie\r\n            success (res) {\r\n              let { data : resData, header, statusCode } = res\r\n              let setCookieStr = header['Set-Cookie'] || header['set-cookie'] || ''\r\n\r\n              CookieLib.setCookieFromHeader(setCookieStr) // 响应头————解析Set-Cookie\r\n              resolve(resData)\r\n            },\r\n            fail (err) {\r\n                reject(err)\r\n            }\r\n          })\r\n    })\r\n}\r\n复制代码如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：1. 请求携带步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到 Request Header 中上面代码中的 getCookiesStr() 直接取cookies拼接即可，返回示例： cookie1=xxx;cookie2=yyy 。2. 响应设置步骤：（每次收到响应后）解析 Response Header 的 Set-Cookie 字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理 Set-Cookie 内容时，有几个点需要留意： - 最基本的格式： Set-Cookie: <cookie-name>=<cookie-value> - 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。3. 编码问题「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅 RFC6265 发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].\r\n“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过 encode 编码后保存下来，所以直接取到的也是 encode 后的值，所以追加在请求头 Cookie 字段，就不需要 decode 解码了，直接拼接即可（但基础库API的get操作最终需要进行 decode 解码）。而对于响应头 Set-Cookie 的值，我们认为后端已经做了 encode 编码，所以前端不需要处理，直接存进 Storage 即可。五、性能优化（高频读写）前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。1. 初始化首先需要在内存中声明一个 _COOKIES （命名自行diy），建议在cookie基础库中声明，便于统一维护。2. 读前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的 _COOKIES 即可。3. 写写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。六、单元测试微信官方在2019年5月推出了「小程序自动化 SDK」 miniprogram-automator ，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：小程序全局范围的cookie验证（比如初始化小程序后，有没有种下版本号、访问行为等关键cookie）cookie基础库API验证（比如get/set/remove等各个API是否正常工作）以验证 setCookie() API为例：it('API验证：setCookie()', async () => {\r\n    await miniProgram.evaluate(() => {\r\n        wx.CookieLib.setCookie({ // 调用API\r\n            cookie1: 12345,\r\n        })\r\n    })\r\n\r\n    let { cookies } = await miniProgram.callWxMethod('getStorageSync', 'cookies')\r\n    expect(cookies['cookie1'].value).toBe(12345) // 期望成功设置cookie1为12345\r\n})\r\n复制代码这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了 wx 对象上，实现方式是使用node读写文件的API去【植入代码】：fs.appendFileSync('./your_project/app.js', ''\\n wx.CookieUtil = require(\\'./lib/cookie.js\\');\\n'')\r\n复制代码七、Cookie安全Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。path、domin、HttpOnly、Secure、SameSite小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此 path、domin、HttpOnly、Secure、SameSite 这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。白名单机制前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。前端防篡改小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个 _Cookies ，如果有一个API getAllCookies() 直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。SessionSession机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。指纹上报用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。八、完整小程序实现Demo代码片段： developers.weixin.qq.com/s/x4sFASmh7…九、小结本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。", "author": "Rolan", "pub_time": "2020-1-13 00:32", "title": "京东购物小程序cookie方案实践 "}
{"content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于 uni-app 框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的小程序的制作思路和实现代码。目录1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验1、完整源码链接：完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。2、实现思路该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用 canvasToTempFilePath 转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用 canvasToTempFilePath 转成图片导出。3、核心代码3-1、文字/图片编辑模块文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。HTML<img\r\n style=\"position: absolute\"\r\n :style=\"{\r\n     left: item.x+'px', \r\n     top: item.y+'px',\r\n     width: item.w+'px',\r\n     height: item.h+'px',\r\n     }\"\r\n  @touchstart='touchStart($event,item,index)' \r\n  @longpress='longPress($event,item,index)'\r\n  @touchmove.stop='touchMove($event,item,index)' \r\n  @touchcancel=\"touchEnd($event,item,index)\" \r\n  @touchend='touchEnd($event,item,index)'\r\n  v-for=\"(item,index) of imagelist\"\r\n  :key=\"index\" \r\n  :src=\"item.src\"\r\n  />在 imageList 的数组标签中，每个绑定的事件中用 $event 来调用事件本身的参数，其中 $event 的 touches 或 changedTouches 包含我们需要的位置参数，示例如下：touches:[{\r\n        clientX: 14 //与显示区域(不含顶部栏)左上角的水平距离\r\n        clientY: 16 //与显示区域(不含顶部栏)左上角的垂直距离\r\n        pageX: 14 //与整个页面(不含顶部栏)左上角的水平距离\r\n        pageY: 16 //与整个页面(不含顶部栏)左上角的垂直距离\r\n        },\r\n        {\r\n        clientX: 14\r\n        clientY: 16\r\n        pageX: 14\r\n        pageY: 16\r\n        }]touches 长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为 style=\"position: absolute\" 所以只需要根据位置参数来更新 x、y、w、h 即可题外话-性能问题一次移动多次操作DOM影响性能—— 虚拟DOM了解一下为何不用事件委派—— 不必要，Vue已经帮我们做了优化，在非常影响性能时再考虑图片编辑Demo3-2、油墨电子签名板由于 touchmove 事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。HTML<canvas \r\ncanvas-id=\"canvas\" \r\n@touchstart.stop=\"touchStart\" \r\n@touchmove.stop=\"touchMove\"\r\n@touchend.stop=\"touchEnd\"\r\n>\r\n</canvas>JAVASCRIPTexport default {\r\ndata() {\r\n    return {\r\n        lineWidth0: 5, //初始线宽 建议1~5\r\n        ctx: null,\r\n        x0: 0, //初始横坐标或上一段touchmove事件中触摸点的横坐标\r\n        y0: 0, //初始纵坐标或上一段touchmove事件中触摸点的纵坐标\r\n        t0: 0, //初始时间或上一段touchmove事件发生时间\r\n        v0: 0, //初始速率或touchmove事件间发生速率\r\n        lineWidth: 0, //动态线宽\r\n        keenness: 5, //油墨程度 建议0~5\r\n        k: 0.3, //油墨因子，即每次绘制线条时线宽的变化程度\r\n    }\r\n},\r\nonReady() {\r\n    this.ctx = uni.createCanvasContext('canvas', this);\r\n    this.ctx.setLineCap('round')\r\n},\r\nmethods: {\r\n    //设置初始值\r\n    touchStart(e) {\r\n        this.lineWidth = this.lineWidth0\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = 0\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n    },\r\n\r\n    touchMove(e) {\r\n        let dx = e.touches[0].clientX - this.x0,\r\n            dy = e.touches[0].clientY - this.y0,\r\n            ds = Math.pow(dx * dx + dy * dy, 0.5),\r\n            dt = (new Date().getTime()) - this.t0,\r\n            v1 = ds / dt; //同 this.v0 初始速率或touchmove事件间发生速率\r\n        if (this.keenness === 0) { //油墨为0时\r\n            this.ctx.moveTo(this.x0, this.y0)\r\n            this.ctx.lineTo(this.x0 + dx, this.y0 + dy)\r\n            this.ctx.setLineWidth(this.lineWidth)\r\n            this.ctx.stroke()\r\n            this.ctx.draw(true)\r\n        } else {\r\n            //由于touchMove的触发频率问题，这里采用for循环绘制，原理如图所示\r\n            //这里的k因为\r\n            let a = this.keenness\r\n            if (this.keenness > 5) {\r\n                a = 5\r\n            }\r\n            for (let i = 0; i < a; i++) {\r\n                this.ctx.moveTo(this.x0 + dx * i / a, this.y0 + dy * i / a)\r\n                this.ctx.lineTo(this.x0 + dx * (i + 1) / a, this.y0 + dy * (i + 1) / a)\r\n                //此时touchmove事件间发生与上一个事件的发生的速率比较\r\n                if (v1 < this.v0) {\r\n                    this.lineWidth -= this.k\r\n                    if (this.lineWidth < this.lineWidth * 0.25) this.lineWidth = this.lineWidth * 0.25\r\n                } else {\r\n                    this.lineWidth += this.k\r\n                    if (this.lineWidth > this.lineWidth * 1.5) this.lineWidth = this.lineWidth * 1.5\r\n                }\r\n                this.ctx.setLineWidth(this.lineWidth)\r\n                this.ctx.stroke()\r\n                this.ctx.draw(true)\r\n            }\r\n        }\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = v1\r\n    },\r\n    touchEnd(e) {\r\n        this.x0 = 0\r\n        this.y0 = 0\r\n        this.t0 = 0\r\n        this.v0 = 0\r\n    }\r\n}\r\n}使用的大部分是canvas的基础api，注意绘制单位都为px。油墨电子签名Demo3-3、开放式海报模块如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——鲁迅说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。HTML<canvas canvas-id=\"generate\" :style=\"{ width: canvasW + 'rpx', height: canvasH + 'rpx'}\"></canvas>相关介绍spread 语法async 函数如果图片是网络路径，记得获取临时路径。//别忘了在函数前加 async\r\nlet src = 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg'\r\nsrc = (await uni.getImageInfo({src}))[1].path;JAVASCRIPT输出字段部分//为方便设置，以下除角度外，单位均以rpx为主\r\ndata() {\r\n    return {\r\n        canvasW:720,\r\n        canvasH:1000,\r\n        img:[{\r\n            src: 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg',\r\n            x: 0,\r\n            y: 0,\r\n            w: 100,\r\n            h: 100,\r\n            r: 50,//圆角度\r\n            degrees: 30,//旋转度\r\n            mirror: true//是否镜像\r\n            }],\r\n        text:[{\r\n                content: 'TensionMax',\r\n                x: 50,\r\n                y: 50,\r\n                w: 100,\r\n                lineHeight: 35,//行间距\r\n                color: '#000000',\r\n                size: 28,\r\n                weight: 'normal',//字体粗细\r\n                lineThrough: true,//是否贯穿\r\n            }],\r\n        ctx: null,\r\n        k: null //单位转换因子\r\n    };\r\n}JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法px2rpx() {\r\n    //当转换的参数只有一个时直接返回数值如\r\n    //当不为一个时返回数组，然后用spread语法将其展开为几个参数\r\n    //Math.floor()是为了防止在安卓机上造成的数据紊乱，开发者工具无此bug\r\n    if (arguments.length === 1) return Math.floor(arguments[0] / this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i / this.k))\r\n    }\r\n    return params\r\n},\r\nrpx2px() {\r\n    if (arguments.length === 1) return Math.floor(arguments[0] * this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i * this.k))\r\n    }\r\n    return params\r\n},JAVASCRIPT绘制图片的函数async drawImg() {\r\nthis.ctx.setFillStyle('#FFFFFF')\r\nthis.ctx.fillRect(0, 0, ...this.rpx2px(this.canvasW, this.canvasH)) //绘制背景\r\nfor (let i of this.img) { //for循环绘制图片\r\n    i.src = (await uni.getImageInfo({src: i.src}))[1].path;//获取图片临时路径\r\n    this.ctx.save() //保存当前绘制内容\r\n    if (i.mirror) { //如果设置镜像\r\n        //因为canvas的translate属性是基于原点（初始原点为右上角）变化\r\n        //所以需要先将原点移动至图片中心，变化后再还原\r\n        //旋转变化同理\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.scale(-1, 1)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    if (i.degrees) { //如果设置旋转\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.rotate(i.degrees * Math.PI / 180)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    this.radiusRect(...this.rpx2px(i.x, i.y, i.w, i.h, i.r)) //圆角或矩形路径绘制\r\n    this.ctx.clip() //裁剪\r\n    this.ctx.drawImage(i.src, ...this.rpx2px(i.x, i.y, i.w, i.h))\r\n    this.ctx.restore() //恢复非裁剪区域\r\n}\r\nthis.ctx.draw(true) \r\n}\r\n\r\nradiusRect(x, y, w, h, r) {\r\n    if (r > w / 2 || r > h / 2) {\r\n        r = Math.min(w, h) / 2\r\n    }\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x, y); // 将操作点移至左上角\r\n    this.ctx.arcTo(x + w, y, x + w, y + r, r); // 画右上角的弧\r\n    this.ctx.lineTo(x + w, y) //可省略，但由于安卓真机的小程序bug，留之，下同。\r\n    this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r); // 画右下角的弧\r\n    this.ctx.lineTo(x + w, y + h) //可省略\r\n    this.ctx.arcTo(x, y + h, x, y + h - r, r); // 画左下角的弧\r\n    this.ctx.lineTo(x, y + h) //可省略\r\n    this.ctx.arcTo(x, y, x + r, y, r); // 画左上角的弧\r\n    this.ctx.lineTo(x, y) //可省略\r\n},绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。开放式海报Demo3-4、小结既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过 props 、 sync 修饰符 等来实现父子通信，当然如果想做更复杂的可以考虑用 Vuex 传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。4、效果展示效果图如下，如果由什么疑问欢迎到下方评论区讨论。", "author": "Rolan", "pub_time": "2020-1-13 00:58", "title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... "}
{"content": "前言对于前端来说，微信的 支付 、 分享 、 登录 是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：域名相关知识介绍该网站不安全，请不要输入密码\r\n微信小程序授权登录流程op=>operation: openid判断是否登录授权\r\nop2=>operation: 根据wx.login获取code\r\nop3=>operation: 调用服务端根据code换取openid\r\nop4=>operation: 通过用户授权，获取信息，存到数据库\r\nop->op2->op3->op4\r\n复制代码如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：服务端官方文档 客户端文档nodejs + 小程序实现授权登录前端部分根据本地是否有userId判断是否登录，如果没有登录，则获取用户的openidonLoad() {\r\n   if(!this.data.userId) {\r\n       this.getSession()\r\n   }\r\n},\r\n getSession() {\r\n   wx.login({\r\n     success: (res) => {\r\n       if (res.code) {\r\n         app.get(Api.getSession, {\r\n           code: res.code\r\n         }).then(res => {\r\n           store.setItem('openid', res.openid)\r\n         })\r\n       }\r\n     }\r\n   })\r\n }复制代码点击授权按钮，发起登录请求。getUserInfo(e) {\r\n    let userInfo = e.detail.userInfo;\r\n    userInfo.openid = store.getItem('openid')\r\n    app.get(Api.login, {\r\n        userInfo\r\n    }).then(res => {\r\n        store.setItem('userId', res.data.userId)\r\n        this.setData({\r\n            userId: res.userId\r\n        })\r\n    })\r\n}复制代码服务端部分在 config 里面，定义公用的 appid 和 appsecretmodule.exports = {\r\n    wx: {\r\n        appId: 'wx0ef10432747d8f57',\r\n        appsecret: 'cc47a6127687e999a1dffa756ff83c0e'\r\n    },\r\n    mp: {\r\n        appId: 'wx0691f1dcf6e5e231',\r\n        appSecret: 'c7ed875e338120f15f49476a6596eb4f'\r\n    }\r\n}复制代码然后通过调用小程序 官方文档 的接口，获取到 appid 传给客户端let express = require('express');\r\nlet router = express.Router();\r\nlet request = require('request');\r\nlet config = require('./config');\r\nlet uril = require('./../../util/index')\r\nconfig = Object.assign({}, config.mp);\r\n\r\nrouter.get('/getSession', (req, res) => {\r\n    let code = req.query.code\r\n    if (!code) {\r\n        res.json(uril.handleFail('code不能为空', 10001))\r\n    }\r\n    let sessionUrl = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.appId}&secret=${config.appSecret}&js_code=${code}&grant_type=authorization_code`;\r\n    request(sessionUrl, (err, response, body) => {\r\n        let result = util.handleResponse(err, response, body)\r\n        res.json(result)\r\n    })\r\n})复制代码登录接口 的编写// 小程序授权登录\r\nrouter.get('/login',async function(req,res){\r\n  let userInfo = JSON.parse(req.query.userInfo);\r\n  if (!userInfo){\r\n    // 如果接口没有信息，则返回错误信息\r\n    res.json(util.handleFail('用户信息不能为空',10002))\r\n  }else{\r\n    // 查询当前用户是否已经注册\r\n    let userRes = await dao.query({ openid: userInfo.openid},'users_mp');\r\n    if (userRes.code == 0){\r\n      // 如果已经注册，直接把查出来的信息返回给客户端\r\n      if (userRes.data.length >0){\r\n        res.json(util.handleSuc({\r\n          userId: userRes.data[0]._id\r\n        }))\r\n      }else{\r\n        // 如果这个用户之前没有注册，则在数据库插入用户信息\r\n        let insertData = await dao.insert(userInfo,'users_mp');\r\n        if (insertData.code == 0){\r\n          let result = await dao.query({ openid: userInfo.openid }, 'users_mp');\r\n          res.json(util.handleSuc({\r\n            userId: result.data[0]._id\r\n          }))\r\n        }else{\r\n          res.json(insertData);\r\n        }\r\n      }\r\n    }else{\r\n      res.json(userRes);\r\n    }\r\n  }\r\n})复制代码上述代码的 handleFail 和 handleResponse 是封装的对数据的统一处理，如果有兴趣，参见 github 地址。这里不展示代码。需要注意的是，这种实现方式，获取 openid 的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权和分享流程H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。 官方文档 给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。mounted(){\r\n   this.checkUserAuth();\r\n },\r\nmethods:{\r\n// 检查用户是否授权过\r\ncheckUserAuth(){\r\n  let openId = this.$cookie.get('openId');\r\n  if(!openId){\r\n    // 如果没有登录授权，则跳转到微信提供的跳转页面。\r\n    window.location.href = API.wechatRedirect;\r\n  }else{\r\n  // 如果用户已经授权，则调用获取微信配置信息接口\r\n    this.getWechatConfig();\r\n  }\r\n},复制代码API.wechatRedirect:wechatRedirect:'/api/wechat/redirect?url=http%3A%2F%2Fm.51purse.com%2F%23%2Findex&scope=snsapi_userinfo',复制代码「注意」url地址需要 encodeURIComponent 编码才可以。m.51purse.com 需要与你在微信公众号后台配置的 授权域名 一致！nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的 接口// 用户授权重定向\r\nrouter.get('/redirect',function (req,res) {\r\n  let redirectUrl = req.query.url, scope = req.query.scope, callback = 'http://m.51purse.com/api/wechat/getOpenId';\r\n  cache.put('redirectUrl', redirectUrl);\r\n  // 获取到客户端带过来的数据，请求微信接口\r\n  let authorizeUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${config.appId}&redirect_uri=${callback}&response_type=code&scope=${scope}&state=STATE#wechat_redirect`;\r\n  res.redirect(authorizeUrl);\r\n})\r\n复制代码当用户点击 确认授权 之后，会执行跳转 callbacl：http://m.51purse.com/api/wechat/getOpenId 。而这个接口也是node端实现的，具体内容如下：// 用code换取access_token的方法\r\nexports.getAccessToken = function(code){\r\n  let token_url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${config.appId}&secret=${config.appSecret}&code=${code}&grant_type=authorization_code`;\r\n  return new Promise((resolve, reject) => {\r\n    request.get(token_url, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  });\r\n}\r\n\r\n\r\n// 根据code获取用户的OpenId\r\nrouter.get('/getOpenId',async function(req,res){\r\n  let code = req.query.code;\r\n  console.log(\"code:\"+code);\r\n  if(!code){\r\n    res.json(util.handleFail('当前未获取到授权code码'));\r\n  }else{\r\n    // 用code换取access_token\r\n    let result = await common.getAccessToken(code);\r\n    if(result.code == 0){\r\n      // 换取access_token成功\r\n      let data = result.data;\r\n      let expire_time = 1000 * 60 * 60 * 2;\r\n      // 往客户端写入cookie：openId\r\n      res.cookie('openId', data.openid, { maxAge: expire_time });\r\n      let openId = data.openid;\r\n      let userRes = await dao.query({ 'openid': openId },'users');\r\n      if (userRes.code == 0){\r\n        if (userRes.data.length>0){\r\n          // 从数据库查找到用户信息后，回调到客户端的页面\r\n          let redirectUrl = cache.get('redirectUrl');\r\n          res.redirect(redirectUrl);\r\n        }else{\r\n          let userData = await common.getUserInfo(data.access_token, openId);\r\n          let insertData = await dao.insert(userData.data,'users');\r\n          if (insertData.code == 0){\r\n            // 从数据库查找到用户信息后，回调到客户端的页面\r\n            let redirectUrl = cache.get('redirectUrl');\r\n            res.redirect(redirectUrl);\r\n          }else{\r\n            // 返回错误信息\r\n            res.json(insertData);\r\n          }\r\n        }\r\n      }else{\r\n        // 返回错误信息\r\n        res.json(userRes);\r\n      }\r\n    }else{\r\n      // 返回错误信息\r\n      res.json(result);\r\n    }\r\n  }\r\n})\r\n复制代码「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。H5分享流程同样，如果你没有阅读过微信H5开发的 官方文档 ,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要 npm install wx-jssdk// 这个信息统一定义在api.js中，这里为了方便，放在前面，便于查看。\r\nAPI.wechatConfig: /api/wechat/jssdk\r\n\r\n\r\n// 获取微信配置信息\r\ngetWechatConfig(){\r\n  this.$http.get(API.wechatConfig+'?url='+location.href.split('#')[0]).then(function(response){\r\n    let res = response.data;\r\n    if(res.code == 0){\r\n      let data = res.data;\r\n      wx.config({\r\n        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\r\n        appId: data.appId, // 必填，公众号的唯一标识\r\n        timestamp: data.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: data.nonceStr, // 必填，生成签名的随机串\r\n        signature: data.signature,// 必填，签名\r\n        jsApiList: data.jsApiList // 必填，需要使用的JS接口列表\r\n      })\r\n      wx.ready(()=>{\r\n        util.initShareInfo(wx);\r\n      })\r\n    }\r\n  })\r\n}复制代码util/index.js 里面对分享的功能进行了封装。export default {\r\n  //获取浏览器地址栏参数值\r\n  getUrlParam(name){\r\n    let reg = new RegExp('(^|&)'+name+'=([^&]*)');\r\n    let r = window.location.search.substr(1).match(reg);\r\n    if(r!=null)return decodeURIComponent(r[2]);\r\n  },\r\n  initShareInfo(wx){\r\n    let shareInfo = {\r\n      title: 'xxxx', // 分享标题\r\n      desc: 'xxxx', // 分享描述\r\n      link: 'http://m.51purse.com/#/index', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致\r\n      imgUrl: '', // 分享图标\r\n    }\r\n    wx.onMenuShareAppMessage(shareInfo);\r\n    wx.onMenuShareTimeline(shareInfo);\r\n    wx.onMenuShareQQ(shareInfo);\r\n    wx.onMenuShareQZone(shareInfo);\r\n    // 下面两种方法为新的方法,上面的方法将会被淘汰。\r\n    wx.updateAppMessageShareData(shareInfo);\r\n    wx.updateTimelineShareData(shareInfo);\r\n  }\r\n}\r\n复制代码nodejs端对 /wechat/jssdk 接口的实现如下：// common.getToken()方法 获取基础接口的Token\r\n\r\nexports.getToken = function(){\r\n  let token = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${config.appId}&secret=${config.appSecret}`;\r\n  return new Promise((resolve, reject)=>{\r\n    request.get(token, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  })\r\n}\r\n----\r\n\r\nrouter.get('/jssdk',async function(req,res){\r\n  let url = req.query.url;\r\n  let result = await common.getToken();\r\n  if (result.code == 0){\r\n    let token = result.data.access_token;\r\n    let params = {\r\n      // 生成随机字符串\r\n      noncestr:util.createNonceStr(),\r\n      // 生成时间戳\r\n      timestamp:util.createTimeStamp(),\r\n      url\r\n    }\r\n      let str = util.raw(params);\r\n      console.log('str:::' + JSON.stringify(params))\r\n      let sign = createHash('sha1').update(str).digest('hex');\r\n      res.json(util.handleSuc({\r\n        appId: config.appId, // 必填，公众号的唯一标识\r\n        timestamp: params.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: params.noncestr, // 必填，生成签名的随机串\r\n        signature: sign,// 必填，签名\r\n        jsApiList: [\r\n          'updateAppMessageShareData',\r\n          'updateTimelineShareData',\r\n          'onMenuShareTimeline',\r\n          'onMenuShareAppMessage',\r\n          'onMenuShareQQ',\r\n          'onMenuShareQZone',\r\n          'chooseWXPay'\r\n        ] // 必填，需要使用的JS接口列表\r\n      }))\r\n    }\r\n  }else{\r\n    res.json(result);\r\n  }\r\n})复制代码以上代码主要获得基础的 token ,然后用基础 token 结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是， 基础token 和 accessToken 的区别。建议 参考文章 。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付小程序支付前端流程获取openId调起数字签名后端支付流程拼接常规参数生成签名拼接xml数据调用下单接口获取预支付Id：prepay_id生成支付sdk定义回调接口，接受微信支付消息支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法/**\r\n * 公共函数定义\r\n */\r\nlet createHash = require('create-hash');\r\nmodule.exports = {\r\n  // 生成随机数\r\n  createNonceStr(){\r\n    return Math.random().toString(36).substr(2,15);\r\n  },\r\n  // 生成时间戳\r\n  createTimeStamp(){\r\n    return parseInt(new Date().getTime() / 1000) + ''\r\n  },\r\n  // 生成签名\r\n  getSign(params, key){\r\n    let string = this.raw(params) + '&key=' + key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 生成系统的交易订单号\r\n  getTradeId(type='wx'){\r\n    let date = new Date().getTime().toString();\r\n    let text = '';\r\n    let possible = '0123456789';\r\n    for(let i=0;i<5;i++){\r\n      text += possible.charAt(Math.floor(Math.random() * possible.length))\r\n    }\r\n    return (type == 'wx'?'ImoocWxJuZi':'ImoocMpJuZi') + date + text;\r\n  },\r\n  // Object 转换成json并排序\r\n  raw(args){\r\n    let keys = Object.keys(args).sort();\r\n    let obj = {};\r\n    keys.forEach((key)=>{\r\n      obj[key] = args[key];\r\n    })\r\n    // {a:1,b:2} =>  &a=1&b=2\r\n    // 将对象转换为&分割的参数\r\n    let val = '';\r\n    for(let k in obj){\r\n      val += '&' + k + '=' +obj[k];\r\n    }\r\n    return val.substr(1);\r\n  }\r\n}复制代码下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的 order 方法。/**\r\n * 微信小程序、H5通用支付封装\r\n */\r\nlet config = require('./../pay/config')\r\nlet request = require('request')\r\nlet util = require('../../util/util')\r\nlet createHash = require('create-hash')\r\nlet xml = require('xml2js')\r\nconfig = config.mch;\r\nmodule.exports = {  \r\n  order: function (appid,attach, body, openid, total_fee, notify_url, ip){\r\n    return new Promise((resolve,reject)=>{\r\n      let nonce_str = util.createNonceStr();\r\n      let out_trade_no = util.getTradeId('mp');\r\n      // 支付前需要先获取支付签名\r\n      let sign = this.getPrePaySign(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no);\r\n      // 通过参数和签名组装xml数据，用以调用统一下单接口\r\n      let sendData = this.wxSendData(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no, sign);\r\n      let self = this;\r\n      let url = 'https://api.mch.weixin.qq.com/pay/unifiedorder';\r\n      request({\r\n        url,\r\n        method: 'POST',\r\n        body: sendData\r\n      }, function (err, response, body) {\r\n        if (!err && response.statusCode == 200) {\r\n          xml.parseString(body.toString('utf-8'),(error,res)=>{\r\n            if(!error){\r\n              let data = res.xml;\r\n              console.log('data:' + JSON.stringify(data));\r\n              if (data.return_code[0] == 'SUCCESS' && data.result_code[0] == 'SUCCESS'){\r\n                // 获取预支付的ID\r\n                let prepay_id = data.prepay_id || [];\r\n                let payResult = self.getPayParams(appid, prepay_id[0]);\r\n                resolve(payResult);\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(util.handleFail(err));\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 生成预支付的签名\r\n  getPrePaySign: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no) {\r\n    let params = {\r\n      appid,\r\n      attach,\r\n      body,\r\n      mch_id: config.mch_id,\r\n      nonce_str,\r\n      notify_url,\r\n      openid,\r\n      out_trade_no,\r\n      spbill_create_ip: ip,\r\n      total_fee,\r\n      trade_type: 'JSAPI'\r\n    }\r\n    let string = util.raw(params) + '&key=' + config.key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 签名成功后 ，根据参数拼接组装XML格式的数据，调用下单接口\r\n  wxSendData: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no,sign) {\r\n    let data = '<xml>' + \r\n      '<appid><![CDATA[' + appid + ']]></appid>' + \r\n      '<attach><![CDATA[' + attach + ']]></attach>' + \r\n      '<body><![CDATA[' + body + ']]></body>' + \r\n      '<mch_id><![CDATA[' + config.mch_id + ']]></mch_id>' + \r\n      '<nonce_str><![CDATA[' + nonce_str + ']]></nonce_str>' + \r\n      '<notify_url><![CDATA[' + notify_url + ']]></notify_url>' + \r\n      '<openid><![CDATA[' + openid + ']]></openid>' + \r\n      '<out_trade_no><![CDATA[' + out_trade_no + ']]></out_trade_no>' + \r\n      '<spbill_create_ip><![CDATA[' + ip + ']]></spbill_create_ip>' + \r\n      '<total_fee><![CDATA[' + total_fee + ']]></total_fee>' + \r\n      '<trade_type><![CDATA[JSAPI]]></trade_type>' + \r\n      '<sign><![CDATA['+sign+']]></sign>' + \r\n    '</xml>'\r\n    return data;\r\n  },\r\n  getPayParams:function(appId,prepay_id){\r\n    let params = {\r\n      appId,\r\n      timeStamp:util.createTimeStamp(),\r\n      nonceStr:util.createNonceStr(),\r\n      package: 'prepay_id=' + prepay_id,\r\n      signType:'MD5'\r\n    }\r\n    let paySign = util.getSign(params,config.key);\r\n    params.paySign = paySign;\r\n    return params;\r\n  }\r\n}复制代码最后定义 /pay/payWallet 的支付接口，里面调用公用的order方法。// 小程序支付\r\nrouter.get('/pay/payWallet',function(req,res){\r\n  let openId = req.query.openId;//用户的openid\r\n  let appId = config.appId;//应用的ID\r\n  let attach = \"小程序支付课程体验\";//附加数据\r\n  let body = \"欢迎学习慕课首门支付专项课程\";//支付主体内容\r\n  let total_fee = req.query.money;//支付总金额\r\n  let notify_url = \"http://localhost:3000/api/mp/pay/callback\"\r\n  let ip = \"123.57.2.144\";\r\n  wxpay.order(appId,attach,body,openId,total_fee,notify_url,ip).then((result)=>{\r\n    res.json(util.handleSuc(result));\r\n  }).catch((result)=>{\r\n    res.json(util.handleFail(result.toString()))\r\n  });\r\n})复制代码这里的流程请参见 官方描述 。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取 签名 。然后根据签名加上其他需要的 参数 (参见上述代码)再凭借xml的数据。然后再调用统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 。生成 prepay_id之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的 payWallet 接口，传入 openId 和 money 即可。然后获取到相应的参数，调用微信提供的 requestPayment 拉起支付即可。主要代码逻辑如下：pay() {\r\n    app.get(Api.payWallet,{\r\n      openId: Store.getItem('openId'),\r\n      money: this.data.index\r\n    }).then((res) => {\r\n      // 支付\r\n      wx.requestPayment({\r\n        timeStamp: res.timeStamp,\r\n        nonceStr: res.nonceStr,\r\n        package: res.package,\r\n        signType: res.signType,\r\n        paySign: res.paySign,\r\n        success: function (errmsg) {\r\n          if (errmsg == 'requestPayment:ok') {\r\n            wx.showToast({\r\n              title: '支付成功',\r\n              icon: 'success'\r\n            });\r\n          }\r\n        },\r\n        fail: function (res) {\r\n          if (res.errMsg == 'requestPayment:fail cancel') {\r\n            wx.showToast({\r\n              title: '支付取消',\r\n              icon: 'none'\r\n            });\r\n          } else {\r\n            wx.showToast({\r\n              title: res.errmsg,\r\n              icon: 'none'\r\n            });\r\n          }\r\n        }\r\n      })\r\n    });\r\n  }\r\n复制代码到这里，小程序端的支付功能就已经实现了。", "author": "Rolan", "pub_time": "2020-1-14 00:32", "title": "小程序、H5登录授权、分享、支付流程 "}
{"content": "场景描述：一般情况下，加入购物车的动画效果都会是上图的3的路线，在这篇文章里，我们来实现1和2路线的加入购物车的动效（3路线的动画效果网上有很多，具体可以参考这篇文章来实现： www.cnblogs.com/greengage/p… ）。实现方式：不管是上图中的哪一种效果，我们都是用CSS3里的cubic-bezier（三次贝塞尔曲线）来实现的。具体什么是三次贝塞尔曲线，可以参考这篇文章： www.bbsmax.com/A/RnJWwpbRJ…#实现流程：1、获取屏幕的高度大小wx.getSystemInfo({//  获取页面的有关信息\r\n      success: function (res) {\r\n        wx.setStorageSync('systemInfo', res)\r\n        var ww = res.windowWidth;\r\n        var hh = res.windowHeight;\r\n        that.globalData.ww = ww;\r\n        that.globalData.hh = hh;\r\n      }\r\n    });\r\n复制代码2、获取点击的位置（购物车的位置我们定为最上方或者最下方），定义移动距离/*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n复制代码3、在css里调用beizer函数.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n复制代码aCartScale是，在曲线的最后，实现了个购物车抖动的动画@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n复制代码至此，流程全部介绍完毕，下面是全部的代码（里面可能有一些没用的css样式代码，读者可以自行根据需要删除）：js代码：var app = getApp();\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isFly:false\r\n  },\r\n\r\n  /*添加到购物车*/\r\n  onAddingToCartTap: function (events) {\r\n    //防止快速点击\r\n    if (this.data.isFly) {\r\n      return;\r\n    }\r\n    this._flyToCartEffect(events);\r\n  },\r\n  /*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n\r\n})\r\n复制代码wxml代码：<view class=\"container detail-container\">\r\n  <view class=\"fixed-btns-box\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n  <view \r\n  style=\"position: fixed;right: 50rpx;bottom:100rpx;width: 100rpx;\"\r\n  class=\"add-cart-btn {{product.stock==0?'disabled':''}}\" bindtap=\"onAddingToCartTap\">\r\n    <text style=\"width: 360rpx\">加入分享</text>\r\n    <image class=\"cart-icon\" src=\"../../imgs/icon/cart.png\"></image>\r\n    <image id=\"small-top-img\" class=\"small-top-img {{isFly?'animate':''}}\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575871576&di=dda9d07660c88bea6553c3279b0a8cf0&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.pc6.com%2Fup%2F2011-9%2F2011926155953.jpg\"\r\n      mode=\"aspectFill\" style=\"{{translateStyle}}\"></image>\r\n  </view>\r\n\r\n\r\n  \r\n\r\n  <view class=\"fixed-btns-box2\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n</view>\r\n复制代码wxss代码：.detail-container {\r\n  background-color:#F9F9F9\r\n}\r\n.detail-header-box,.detail-bottom-box{\r\n  background-color: #fff;\r\n}\r\n.detail-topic-img{\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.detail-topic-img image{\r\n  width: 100%;\r\n}\r\n\r\n.fixed-btns-box{\r\n  position: fixed;\r\n  top:50rpx;\r\n  right:12px;\r\n  width: 80rpx;\r\n\r\n}\r\n.fixed-btns-box2{\r\n  position: fixed;\r\n  right:12px;\r\n  width: 80rpx;\r\n  bottom: 50rpx;\r\n\r\n}\r\n.fiexd-cart image{\r\n  height: 64rpx;\r\n  width: 64rpx;\r\n}\r\n.fiexd-cart view{\r\n  font-size: 24rpx;\r\n  background-color: #AB956D;\r\n  color: white;\r\n  position: absolute;\r\n  right: 64rpx;\r\n  top: 0rpx;\r\n  height: 36rpx;\r\n  width: 36rpx;\r\n  line-height: 36rpx;\r\n  border-radius: 36rpx;\r\n  text-align: center;\r\n}\r\n.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n\r\n@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n.product-counts,.add-cart-btn{\r\n  height: 100%;\r\n  display: flex;\r\n  font-size: 24rpx;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n.product-counts{\r\n  width: 50%;\r\n}\r\n.add-cart-btn{\r\n  position: relative;\r\n  flex: 1;\r\n}\r\n.add-cart-btn:active{\r\n  color: #fff;\r\n}\r\n.add-cart-btn.disabled{\r\n  color: #D5D5DB;\r\n}\r\n\r\n\r\n\r\n.small-top-img{\r\n  height: 160rpx;\r\n  width: 160rpx;\r\n  right:6rpx;\r\n  position: absolute;\r\n  opacity: 0;\r\n}\r\n.small-top-img.animate{\r\n  opacity: 1;\r\n  -webkit-transition:all 1000ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\r\n}\r\n\r\n\r\n\r\n\r\n.add-cart-btn .cart-icon{\r\n  margin-left: 40rpx;\r\n  height: 32rpx;\r\n  width: 32rpx;\r\n}\r\n\r\n\r\n.disabled{\r\n    pointer-events: none;\r\n}\r\n\r\n复制代码", "author": "Rolan", "pub_time": "2020-1-14 00:42", "title": "微信小程序加入购物车动画的实现（向上、向下） "}
{"content": "基于对 AI 的爱好与兴趣，我走上了独自钻研机器学习的道路。和所有热爱 AI 的人们一样，在一段孤独的摸索旅程中，我勉强完成了几次深度学习模型的训练。其中令我印象较深的成果就是情感分类模型。他能够根据你的文字生成其背后作者的喜怒哀乐。深度学习模型展示出来的 \"人性化\"让我感到惊喜，于是我开始思考怎么将它的“人性化”转化为帮助人们的工具。在情感模型的基础上建立一个上层应用，让它为人类社会中增添不一样的烟火。基于多方面的考量，我最终选择开发一款 微信 \"情感\" 小程序。故事拉开序幕在进行小程序开发之前，我们非常有必要先对小程序做一个充分的了解。什么是小程序简单来说，比起传统的 App，微信小程序是一种全新的连接用户与服务的方式，它具有非常出色的使用体验，并且它可以在微信内被便捷地获取与传播。小程序发展史实际上，小程序并非凭空而来的。当微信逐渐流行、变成几乎人人都离不开的社交工具时，承载微信的 WebView 也逐渐成为了量级最大的移动 Web 入口。每天访问 WebView 的数量甚至超过了访问所有浏览器的总和。虽然无法通过第三方获取到微信 WebView 的日活数据，但这个客观事实间接促进了小程序的诞生。其实在小程序正式步入人们视线之前，微信早已有了类似的 js 调用接口，这里给大家展示一个调用了微信 js-bridge 原生组件去浏览图片的例子：WeixinJSBridge.invoke('imagePreview', {\r\ncurrent: 'http://inews.com',\r\nurls: [ // 所有图片的URL列表，数组格式\r\n    'https://img/1.jpg',\r\n    'https://img/2.jpg',\r\n    'https://img/3.jpg'\r\n]\r\n}, function(res) {\r\n    console.log(res.err_msg)\r\n})\r\n复制代码此类 js 接口其实最开始是专门给腾讯内部人员去进行调用的，但却意外被许多个人开发者发现很多并进行了使用，这也慢慢成为了微信中网页的标准。在 15 年开始的时候，微信官方发布了一套专门用于进行网页开发的工具包，名为 js-sdk ，在这个工具包内开放了如微信支付、录音、语音识别、等数十个接口。这给所有的 Web 开发者都打开了一扇从未开启过的全新的大门，让所有的开发者都可以自由地使用微信开发的原生能力，这使得他们可以去完成一些之前无法完成或是难以做到的事情。js-sdk 完美继承了 WeixinJSBridge 的特性，并且由只对内部开放转为了对外部开放。并且它通过其暴露的微信调用接口使得所有 Web 开发者有了更多操作微信功能的能力。但是，这个模式并没有很好地解决移动网页的体验问题：用户访问页面时，在页面显示前会有一段比较明显能够被感知的白屏过程。受限于网速与不同终端的性能，这个问题会越来越明显。于是乎，js-sdk 的增强版本就诞生了，其中有一个非常重要的新特性，被称之为： 微信 Web 资源离线存储 。​以下文字引用自内部的文档（没有最终对外开放）：微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。相信大家都已经看明白了，这其实就是 HTML5 中 Application Cache 的加强版。然而，在经过了多次测试后发现，还有问题没有被完全的解决：页面切换较为生硬；点击有明显延滞的感觉。最终微信意识到 js-sdk 无法处理这些问题，这需要一个全新的系统去完成，而这个系统必须具备以下几个能力：加载速度快原生的体验易用且安全的微信数据开放兼顾开发效率与开发难度而这就是小程序的由来。故事开始了前言首先请大家见谅，这一篇文章并不会教你如何零基础开发小程序。如果你是一个软件开发新手。那么我建议你先了解一些基础的 js 语法 以及相应的 前端知识 。掌握前端基础后，相信在 小程序前端组件官方文档 的帮助下，任何人都可以快速上手开发小程序。下面我主要跟大家分享两个最核心、 最省钱 的两个小程序开发技巧：搭建小程序云开发环境；如何使用云开发调用 AI 模型接口。小程序云开发在刚开始考虑开发小程序时，和你们一样，我有着许多的顾虑：需要购买域名、服务器吗？维护成本大吗？带着这些顾虑，我小心翼翼地翻开了 微信官方文档 。在大脑经过分布式阅读过后，我发现了 云开发 这个关键词。什么是云开发？微信官方文档中是这么解释的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。云开发提供了几大基础能力支持：简单来说，有了云开发， 我不需要购买服务器就可以开发一款全栈小程序。嘿嘿，没错，这就是我想要的。如何搭建小程序云开发环境那么如何搭建云开发环境呢，综合官方文档，我总结了一套极简搭建教程，大家可以作为参考。云开发环境极简搭建四部曲：首先，需要 注册一个小程序账号 ，添加管理员 / 开发者微信账号并记录下 APPID；接着需要下载 小程序开发工具 ；然后使用管理员 / 开发者账号登录开发工具并填入小程序的 APPID 以及勾选 云开发 选项后点击新建；点击页面中的云开发，跟着提示选择 免费版云开发配额 。至此一个云环境就算是搭建完毕了。什么是云函数？云开发环境搭建完毕后，是时候看看什么是 云函数 了。官方的定义如下：云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。简单来说，云函数就是运行在云端的函数。云函数有什么用？云函数大有用处。有了它，就相当于是有了一个 \"大后端\"，所有业务逻辑以及对数据库的操作我们都可以封装在云函数中调用，十分方便。第一个云函数说了这么多大道理，是时候来实战一下了。右键点击云函数环境 （cloudfunctions | xxxxxxx）后新建一个名为 test 的云函数：可以看到默认的文件（index.js）中已经有了云函数代码（获取当前微信用户上下文，并返回用户信息）：// 云函数入口文件\r\n\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n\r\nexports.main = async (event, context) => {\r\n\r\n\tconst wxContext = cloud.getWXContext()\r\n\r\n\treturn {\r\n\r\n\t\tevent,\r\n\t\t\r\n\t\topenid: wxContext.OPENID,\r\n\t\t\r\n\t\tappid: wxContext.APPID,\r\n\t\t\r\n\t\tunionid: wxContext.UNIONID,\r\n\t\r\n\t}\r\n\r\n}\r\n复制代码这时候需要开启命令行并进入到该目录下运行 npm install 安装 wx-server-sdk ( 若目录下没有 node_modules 则需要先运行 npm init )：最后右键点击该云函数并选择 开启云函数本地调试 后点击右下角调用：可以看到函数执行成功并拿到了返回值（openid 等信息......）至此，恭喜我们快速完成了第一个云函数。如何在小程序中快速调用 AI 模型来自清晨的灵光一闪相信大家都非常好奇，我是怎么做到在云函数中 \"零成本\" 调用 AI 能力的。其实我开始也非常苦恼这个问题，即使小程序有云函数的功能，但也没办法轻易 \"零成本\" 调用 AI 模型，原因如下：小程序云函数目前仅支持 node.js，而我的模型调用接口代码为 python；不管再怎么 \"云\"，想要运行自己的 AI 模型必须得有一台 16G 内存以上的机器（成本巨大）；即使有了自己的服务器也需要域名备案，实在是太麻烦了；但就在一个明媚的清晨，我翻身起床后突然灵光一闪：可不可以调用腾讯自己的 AI 开放接口间接达到这个目的呢？想法再多不如动手行动，于是我访问了 腾讯云控制台的自然语言处理模块 。根据指引进行服务开通后，我进入到 API 密钥管理 并记录下了 API 密钥：那么如何在小程序中调用它呢？我再一次陷入了深深的沉思......云函数调用 AI 模型在经过漫长的探索后我回到了 test 云函数目录下的命令行，安装了腾讯云服务调用包：npm install tencentcloud-sdk-nodejs\r\n复制代码然后修改 test 云函数 （index.js）：// 云函数入口文件\r\n\r\nconst cloud = require('wx-server-sdk')\r\n\r\nconst tencentcloud = require(\"tencentcloud-sdk-nodejs\");\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n\r\nexports.main = async (event, context) => {\r\n\r\n\tconst  NlpClient = tencentcloud.nlp.v20190408.Client;\r\n\t\r\n\tconst models = tencentcloud.nlp.v20190408.Models;\r\n\t\r\n\tconst  Credential = tencentcloud.common.Credential;\r\n\t\r\n\tconst  ClientProfile = tencentcloud.common.ClientProfile;\r\n\t\r\n\tconst  HttpProfile = tencentcloud.common.HttpProfile;\r\n\t\r\n\tlet cred = new  Credential(event.secretId, event.secretKey);\r\n\t\r\n\tlet httpProfile = new  HttpProfile();\r\n\t\r\n\thttpProfile.endpoint = \"nlp.tencentcloudapi.com\";\r\n\t\r\n\tlet clientProfile = new  ClientProfile();\r\n\t\r\n\tclientProfile.httpProfile = httpProfile;\r\n\t\r\n\tlet client = new  NlpClient(cred, \"ap-guangzhou\", clientProfile);\r\n\t\r\n\tlet req = new models.SentimentAnalysisRequest();\r\n\t\r\n\tlet text = event.text\r\n\t\r\n\tlet params = '{\"Text\":\\\"' + text + '\\\"}'\r\n\t\r\n\tconsole.log('待预测字符串： ' + text)\r\n\t\r\n\treq.from_json_string(params);\r\n\t\r\n\tclient.SentimentAnalysis(req, function (errMsg, response) {\r\n\t\r\n\t\tif (errMsg) {\r\n\t\t\r\n\t\tconsole.log(errMsg)\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\tconsole.log('AI 预测情绪正值: ' + response.Positive)\r\n\t\t\r\n\t\tconsole.log('AI 预测情绪负值: ' + response.Negative)\r\n\t\t\r\n\t})\r\n\r\n}\r\n复制代码在这段代码中，我通过腾讯云账号中的密钥连通了 AI 情感预测接口，最后将情感预测的结果打印了出来。接下来我开启了本地云函数调用窗口并传入相应参数：secretId （腾讯云 API 服务密钥 Id ）secretKey （腾讯云 API 服务密钥 Key）text （待预测的字符串）然后点击调用后终于看到了 AI 模型的预测结果：最后我成功地使用云函数调用了免费的 AI 开放接口。这时我已经热泪盈眶，除了感动还有一丝小满意，原来云开发还能这么玩。故事的结尾文章到这里，相信最重要的两个部分大家已经了解并掌握了：搭建云开发环境快速调用 AI 模型回头望去，整个小程序开发过程大概历经三天两夜，整段经历大概与 \"编程马拉松\" 类似。编程马拉松，又称黑客日、黑客节或编程节，是一个流传于黑客当中的新词汇。编程马拉松是一种活动。在该活动当中，计算机程序员以及其他与软件发展相关的人员，如图形设计师、界面设计师与项目经理，相聚在一起，以紧密合作的形式去进行某项软件项目。编程马拉松的灵魂是合作地编写程序和应用。编程马拉松的时长一般在几天到一周不等 。--维基百科于是乎，在经过 \"疯狂\" 开发后，一个日记小程序的雏形就诞生了。虽然说前端页面并没有多复杂，但是确实倾注了许多开发心血。开发完成的那一刻我已经不在乎是否有人真正去使用他。因为我已经从他身上收获到了全身心投入开发的快乐。最后，老铁，要不点个赞再走可好？么么哒1、给俺点个赞呗，可以让更多的人看到这篇文章，顺便激励下我，嘻嘻。2、老铁们，关注我的原创微信公众号「智能测试开发」，专注于写 AI 与测试开发的结合（AI + 测试 + 开发）。保证让你看完有所收获，不信你打我。后台回复『进阶教程』，免费送你一套关于测试与开发的进阶教程。作者简介作者：大家好，我是泰斯特，从测试入门，再转战开发，最后学习 AI。深知 AI 对测试与开发的影响力。，所以申请了一个微信公众号『智能测试开发』，泰斯特期待你的关注，和我一起学习。 转载说明：未获得授权，禁止转载最后预祝所有用心实践的读者都能开发出有特色的 AI 小程序~", "author": "Rolan", "pub_time": "2020-2-5 00:32", "title": "我是怎么在 3 天内开发 AI 微信小程序的 "}
{"content": "微信发布了小程序的自动化测试框架Minium，提供了多种运行验证方式，其特点：支持一套脚本，iOS & Android & 模拟器，三端运行提供丰富的页面跳转方式，看不到也能去得到可以获取和设置小程序页面数据，让测试不止点点点可以直接触发小程序元素绑定事件支持往 AppSerive 注入代码片段可以调用部分 wx 对象上的接口官方地址如下： https://git.weixin.qq.com/min...minium 是为小程序专门开发的自动化框架, 提供了 Python 和 JavaScript 版本。使用 minium 可以进行小程序 UI 自动化测试, 但是 minium 的功能不止于仅仅是 UI 自动化, 甚至可以使用 minium 来进行函数的 mock, 可以直接跳转到小程序某个页面并设置页面数据, 做针对性的全面测试, 这些都得益于我们开放了部分小程序 API 的能力。除此之外，小程序有部分组件使用了系统原生的组件，对于这部分的组件，我们也基于 uiautomator 和 wda 做了补充。环境依赖Python 3.x微信公共库版本 >= 2.7.3下载并安装稳定版微信开发者工具，工具下载地址： https://developers.weixin.qq....如果要测Android，请下载微信测试包，下载地址： http://dldir1.qq.com/weixin/a...文档使用Minium的文档是采用Nodejs编写的，因此想看文档还需要安装NodeJs的环境，如果你不知道怎么安装请自行查找。文档的安装：npm i docsify-cli -g然后checkout文档项目：git clone https://git.weixin.qq.com/minitest/minium-doc安装依赖：cd minium-doc\r\nnpm install本地部署：docsify serve .然后通过浏览器访问 http://localhost :3000 即可以查看了。框架依赖运行环境部署首先你要先下载框架压缩包： https://git.weixin.qq.com/min...接下来，你要打开微信开发者工具的安全模式然后安装Minium:pip3 install minium-0.0.2.zip使用首先你要通过命令行启动开发者工具提供了命令行命令行通过命令行调用安装完成的工具可执行文件，完成登录、预览、上传、自动化测试等操作。调用返回码为 0 时代表正常，为 -1 时错误。命令行工具所在位置：macOS: <安装路径>/Contents/MacOS/cli\r\n\r\n   Windows: <安装路径>/cli.bat命令行启动工具-o, --open [projectpath]: 打开工具，如果不带 projectpath，只是打开工具。如果带 project path，则打开路径中的项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。projectpath 不能是相对路径。项目路径中必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。示例：# 打开工具cli -o# 打开路径 /Users/username/demo 下的项目cli -o /Users/username/demo输入如下命令：path/to/cli --auto /miniprogram/project/path --auto-port 9420\r\n\r\n# path/to/cli 是命令行工具所在位置：\r\n# macOS: <安装路径>/Contents/MacOS/cli\r\n# Windows: <安装路径>/cli.bat windows版本在安装之后默认会把cli加入到系统路径，可以先测试cli命令是否可用，如果可用，path/to/cli可以直接用cli替换\r\n\r\n# /miniprogram/project/path 是小程序工程的路径( Windows下面用 \\\\ 代替 \\ )特别说明：1、这里的--auto-port请填写 9420，不是开发者工具安全模式的端口2、请确保开发者工具登陆的微信号具备被测小程序的开发者权限3、如果没有Open project with automation enabled success的输出，否则请检查IDE版本（开发者工具调试基础库版本 >= 2.7.3），或者检查命令行参数关注我，关注测试", "author": "Rolan", "pub_time": "2020-2-5 00:52", "title": "微信小程序的自动化测试框架 "}
{"content": "近期组内接了小程序项目，也是有幸能够加入到项目中，做一些简单的开发。之前对小程序有所接触，但是仅限于自己了解和书写demo，真正项目开发还是第一次~开发过程中也是遇到了一些不熟悉和自己觉得是小坑的地方，做个简单总结，给自己做个记录，同时给需要的小伙伴一些小小参考。一、添加一个新组建，控制台报错“Component is not found in path '../../components/xx/xx'”。答：这个问题开始是很迷茫的，仔细检查了文件名称、引用路径以及父组件usingComponents，都没有发现有问题，但是控制台依旧提示找不到对应组件。后面经过大老提示： 对于一个新的组件，必须在对应的js里添加Component({})，json文件里也要写上component:true。加上相关配置后，控制台就不会飘红了。二、text组件，默认会出现上内边距。答：使用text组件展示文字内容，看上去并没有什么技术而言，直接引用就好了（心里默默开森）<text>\r\n  this is component\r\n</text>复制代码但是，看到效果之后，显然有点蒙圈，为什么上边会出现那么大的距离啊？！第一个想法是去看css，是否有默认内边距样式，然而并没有；通过padding、margin去设置值，也没什么用；然后。。然后。。。我就不知道怎么办了，只好请教度娘。网上有小伙伴给出了答案，其实并不是样式问题，而是text组件本身问题，要修改这个问题，只需要把text标签和内容写在一行就可以了。<text>this is component</text>\r\n复制代码三、小程序分享功能，页面分享和按钮分享功能。答：众所周知，小程序是可以进行分享的，有两种方式，一个是自带的分享功能，另一个是页面上按钮点击分享。本质上他们调用的是同一个方法，即onShareAppMessage，可以通过options参数的options.from区分是来自按钮还是原生分享，可以通过设置对应字段修改分享展示的内容，不设置则默认分享当前页。onShareAppMessage (res) {\r\n  // 来自页面内转发按钮    \r\n  if (res.from === 'button') {\r\n     return {\r\n        title: `标题`,      //分享标题        \r\n        path: shareUrl,    //分享的链接        \r\n        imageUrl:‘’        //分享展示的图片           \r\n     };    \r\n   } else {      \r\n     return {        \r\n       title: `分享标题`,        \r\n       imageUrl:''    \r\n     };\r\n   }\r\n}复制代码按钮分享，只需要给button添加一个open-type即可，<button open-type=\"share\"></button>。但是此时按钮会有默认样式，可以通过控制台查看，进行css修复样式，分享回调同样调用上边方法。四、小程序内获取某个元素或者组件距离顶部初始高度答：实际开发中，我们基本会遇到需要获取某个元素位置信息的需求，早在jq一把梭的时代，获取这些属性值是很容易的，直接一个api就可以了。同样的小程序里也有比较实用的方法，我们可以给需要获取位置的元素/组件一个id，然后通过下面方法即可获取：let query = wx.createSelectorQuery().in(this);\r\nquery.select('#testId').boundingClientRect(function(rect){\r\n    //rect即包含了所需要的各种位置信息，如top、left、right、bottom等\r\n})复制代码如果在页面初始化时需要获取到位置，可以在onLoad方法里使用（最好使用setTimeout，否则可能会取不到），获取对应值之后就可以进行后续的处理了。五、scroll-view组件使用答：滚动组件的使用，在开发中可以说很普遍了。小程序也封装了scroll-view组件，并提供了一些封装好的方法，使用起来可以说很方便了，但是也不可避免的有一些需要注意的地方。1、scroll-view的绑定scroll事件不触发当页面组件按照文档方法书写完成后，去滚动页面发现页面滚动事件并没有触发，后面经过仔细查看，确定问题原因是scroll-view没有设置高度，而且必须是精准高度，不能用百分比。2、scroll-view滚动到某一位置我们开发时可能需要用到点击后滚动到某一位置或者初始化时滚动到对应位置，过去通常是通过锚点方式进行触发，同样的scroll-view为我们封装了一个很好用的方法scroll-into-view，对应的值也是一个id值，具体使用方法及注意事项可以参考文档（ scroll-view ）。3、scroll-view中包含fixed定位元素，滚动时fixed定位元素闪动这个问题算是比较坑了，在scroll-view里面，我们设置某个元素或者组件为fixed定位，在滚动页面时，会发现定位的元素会消失一下然后再出现，虽然不是什么严重问题，但是很影响用户体验。这个问题我看到社区里也有很多人在问，但是目前官方还没有给出合理方法。目前简单的应对方法我总结了两点：一是把定位元素放到scroll-view外部，此类方法可以完美避开上述问题，但是某些场景下可能不太适用；二是，在使用scroll-view时我们通常会设置scroll-with-animation=true即开启滚动过度动画效果，当我们把这个值设置为false时，上述问题也能很好的解决，即使定位元素在scroll-view内部也不会有闪现问题。但是此方法牺牲的也是用户体验，如果有短距离的页面滚动可以使用此类方法。欢迎遇到此类问题的小伙伴进行补充，在官方给出完美方案之前，我们也能有自己的应对方案。六、小程序checkbox样式这个就不得不吐槽一下UI了，其他的都还好，但是对于表单相对应的样式，真的是丑爆了！而且，当你想通过css样式覆盖方法修改的时候，会发现，你的修改根本就是不起作用的！！根本原因就是你所看见的wxml结构与内容和样式所定义的根本不是一个样子！！！当然也有机智的小伙伴探究出了方案（以checkbox为例）：//wxml\r\n<label>\r\n    <checkbox>aaa</checkbox>\r\n</label>\r\n\r\n//wxss\r\n//修改checkbox大小\r\ncheckbox .wx-checkbox-input{}\r\n//修改checkbox选中后的样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked{}\r\n//修改checkbox选中图标样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before{}复制代码当然，如果你不喜欢原组件，不想去修改css，完全可以自己仿写一个checkbox，样式自己写，切换效果通过点击事件（参数e，获取data）自己控制就好。关于表单内容，后面会再总结一个自定义表单及自定义校验方法及自己进行的优化。七、小程序页面跳转，跳转到其他域名页面小程序页面跳转，我们可以通过wx.navigateTo()方法进行，但是当需要跳转到不同域页面时，直接跳转链接的方式就不好用了。小程序也为我们提供了方法，即webb-view( 使用方法见文档)。以上就是在初次开发中遇到的问题及总结的使用方法，后面随着使用的增多，肯定还会有更多的问题出现，随时进行添加吧，算是对小程序使用自己的一个总结，有不足和错误之处，还希望各位大大提出宝贵意见。ps：前期初次接触小程序书写demo时，也遇到了一些小问题，付个传送门：初试微信小程序遇到的问题总结", "author": "Rolan", "pub_time": "2019-12-31 00:05", "title": "小程序初实践总结 "}
{"content": "随着业务需求的不断累加、小程序追求快速产出。在人手不足且开发周期较短的情况下，我们需要找到一个最大化开发效率的方法。而高效率的开发离不开规范化、工程化、组件化。为此整理写下总结，细数小程序中的坑与实践。介绍我们对小程序高效率开发的思考与探索。布局方案导航栏TabBarBasicPage用户系统登录方案初始化登录鉴权优化及 Bug 追踪日志收集数据分析常用优化方案preLoad独立分包加载布局方案我们首先思考的是，在小程序中如何快速且高还原产出页面。为此我们封装了一套页面组件。导航栏目前小程序有如下两种导航栏：常规、自定义导航栏自定义导航栏布局下，我们可以完全控制导航栏样式，赋予导航栏更多交互及 UI 设计上的可能。如上图所示，Readhub 在导航栏中加入了设置按钮，喜茶在个人页中标题渐隐及沉浸式导航栏效果。常规布局下，顶部导航栏部分直接使用小程序提供导航栏。可根据具体业务选择具体布局方案，在我们小程序中，我们选择了全部使用自定义导航栏的方式并对其进行了一定封装。在确定使用自定义导航栏方案后，我们对导航栏进行了拆解拆解后，我们发现可以将自定义导航栏分为两个部分：StatusBar 及 NavigationBar 。通过查阅微信 API ，我们分别通过 wx.getSystemInfoSync 及 wx.getMenuButtonBoundingClientRect 获取到 StatusBarHeight 及 MenuButton 的布局信息。由拆解图可知1 NavigationBarPaddingTop = MenuButtonTop - StatusBarHeight\r\n3 NavigationBarPaddingBottom = NavigationBarPaddingTop\r\n5 NavigationBar = StatusBarHeight + NavigationBarPaddingTop + NavigationBarPaddingBottom + MenuButtonHeight复制代码得到上述数据后，结果简单封装， 我们得到如下方案StatusBar 部分， 我们使用 PaddingTop 填充。可在此基础上可再进一步封装一些通用 NavigationBar 组件。我们封装了一些常用 NavigationBar 组件， 如下所示：沉浸式导航栏自定义 TabBar目前小程序 TabBar 中也存在两种方案。常规 TabBar ：微信提供方案，可修改 icon 、 文字及其对应选中状态。自定义 TabBar ：小程序基础库 2.5.0 开始支持。可通过其实现异形 TabBar 或各种自定义样式。在我们小程序中，我们选择全部使用自定义 TabBar 来实现业务。由于小程序基础库 2.5.0 之后官方才开始支持自定义 TabBar 。我们此处不直接选择使用 custom-tab-bar 方案。选择结合 custom-tab-bar 、 自定义组件及 wx.hideTabBar 的方案实现。具体方案为放置空节点 custom-tab-bar 文件。在页面中按需引入自定义 TabBar 组件。在页面初始化完成后调用 wx.hideTabBar 隐藏原 TabBar 。这样做的好处在于，在基础库 2.5.0 及更高版本时正常显示，在低版本时以最小代价兼容。在 iPhone X 系列下的底部安全区兼容方案如下 1@mixin media-style() { 2  .tab { 3    padding-bottom: 84px; 4  } 5} 6// 适配iPhone X系列下巴 7@media screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) { 8    @include media-style(); 9}1011@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:3) {12    @include media-style();13}1415@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio:2) {16    @include media-style();17}18// 下面代码只为适配iPhone X在微信调试模拟器中为724px19@media screen and (device-width: 375px) and (device-height: 724px) and (-webkit-device-pixel-ratio: 3) {20    @include media-style();21}复制代码推荐如无特殊需求，建议直接使用微信提供方案，在自定义 TabBar 方案中 安卓手机下拉刷新时， TabBar 会被拉出可视区域。需自定义下拉刷新组件解决方案整合 BasicPage以上方案在线上运行一段时间后稳定后。对自定义导航栏及自定义 TabBar 方案进行了整合。封装了 BasicPage 组件。以我们线上典型页面为例，我们可以将页面分为两大类。基于以上分析结合线上需求，我们对此基础组件进行封装。Taro 框架伪代码，可根据各自使用框架进行封装，思路一致 1class BasicPage extends Taro.Component { 2 3  state = { 4    menuButtonHeight: 32, 5    menuButtonTop: 48, 6    statusBarHeight: 44, 7  }; 8 9  componentDidMount() {10        // ...获取并设置 menuButtonHeight 、 menuButtonTop 、 statusBarHeight11  }1213  render() {14    return (15      <View className='basic-page'>16        {17          this.props.header && <View className={`basic-page-header${this.props.fixed ? ' fixed' : ''}`} style={{18            paddingTop: `${this.state.statusBarHeight}px`,19            height: `${(this.state.menuButtonTop - this.state.statusBarHeight) * 2 + this.state.menuButtonHeight}px`,20          }}21          >22            {this.props.renderHeader}23          </View>24        }25        <View className={`basic-page-body${this.props.tab ? ' tab' : ''}`}>26          {this.props.renderBody}27        </View>28        {this.props.tab && <TabBar active={this.props.tabActive} />}29      </View>30    );31  }32}3334BasicPage.defaultProps = {35  fixed: false, // header 是否浮动36  tab: false,37  header: false,38  tabActive: 'template',39};40复制代码使用中会经常用到 自定义 TabBar 、 自定义 NavigationBar 布局数据。再封装一个工具类获取。 1import Taro from \"@tarojs/taro\"; 2 3function rpx2px(rpx, windowWidth) { 4  return rpx / 750 * windowWidth; 5} 6 7export default class customConfig { 8 9  static fetchAllConfig() {10    const menuButton = Taro.getMenuButtonBoundingClientRect();11    const systemInfo = Taro.getSystemInfoSync();1213    const statusBarHeight = systemInfo.statusBarHeight;14    const headerHeight = (menuButton.top - systemInfo.statusBarHeight) * 2 + menuButton.height;15    const footerHeight = systemInfo.model.indexOf('iPhone X') === -116      ?17      rpx2px(100, systemInfo.windowWidth)18      :19      rpx2px(168, systemInfo.windowWidth);  // 50  8420    const bodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight - footerHeight;21    const noTabBodyHeight = systemInfo.windowHeight - statusBarHeight - headerHeight;2223    let data = {24      source: {25        menu: menuButton,26        system: systemInfo,27      },28      height: {29        statusBar: statusBarHeight,30        header: headerHeight,31        body: bodyHeight,32        noTabBody: noTabBodyHeight,33        footer: footerHeight,34      },35    };36    Taro.setStorageSync('customConfig', data);37    return data;38  }3940  static get config() {41    let storageInfoSync = Taro.getStorageSync('customConfig');42    if(!storageInfoSync) {43      storageInfoSync = this.fetchAllConfig();44    }45    return storageInfoSync;46  }47}复制代码到此，我们完成对基础页面组件的封装。目前线上运行小程序所有页面都基于该组件进行开发。开发新页面时只需要引用该组件即可。1<BasicPage header tab tabActive='index' 2        renderHeader={ 3          <View 4            className='my-index-header' 5          > 6            <Text>Title</Text> 7          </View> 8        } 9        renderBody={10          <View className='my-index-header'>11            Body12          </View>13        }14/>复制代码用户系统在一个应用中，用户系统是至关重要的。我们通过数个小程序的开发，整理了一套我们目前正在使用的用户系统实践。登录、获取用户信息如上图所示，我们将小程序登录及获取用户信息拆分为两部分。主要有如下考虑：降低用户使用门槛，可先让用户体验部分功能。后续分享或互动时提示授权完善用户信息保证始终持有用户登录态，方便程序处理。如把用户登录及完善用户信息放置一起，在未授权时无法获取自定义登录态。判断变得复杂且无法提前收集 formId同一开发者账号下，多小程序互通时，如有一小程序用户授权过，可通过返回 unionid 直接同步信息，无需再授权，提升用户体验。处理注意点授权获取用户信息时，如果服务端未记录用户 sessionKey ，在 Button type = getUserInfo 回调事件中使用 wx.login 方法获取 code 的话，会导致 sessionKey 变化。从而导致 getUserInfo 时使用 sessionKey 与新 sessionKey 不匹配。从而导致解密用户信息失败。解决方案有如下两种：Button type = getUserInfo 回调事件中使用 wx.login 方法后，再次调用 wx.getUserInfo 方法重新获取加密用户信息。服务端记录 sessionKey ，Button type = getUserInfo 回调后无需调用 wx.login ，直接提交供服务端处理。第一种方案适合简单改造旧项目、快速开发，但强烈建议使用服务端处理方式解决。完善用户信息时，解密用户信息部分请查看官方文档，这里不叙述具体流程https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.htmlunionid 机制另外，在登录流程中服务端向微信换取 sessionKey 过程中，如果满足一定条件，会直接返回 unionid 。同开发者账号下多个小程序时可用 unionid 做用户信息同步，无需再授权。提升用户体验。unionid 机制: https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html小程序初始化及页面初始化处理在日常开发中，我们通常会把登录获取 token 操作放置在小程序初始化中即 app.js 定义的 onLaunch 中。而该生命周期与页面初始化生命周期为同步进行。此时，如果在页面初始化中，需要携带用户登录态请求接口获取信息时，可能出现如下情况因为小程序初始化及页面初始化是同步进行的。若页面初始化时，小程序初始化中登录请求仍未完成。会导致未携带 token 或其他鉴权信息，鉴权失败。最开始我们通过在组件中挂载一个特殊事件 componentDidInit ，待小程序初始化登录请求后获取当前页面实例进行调用。但该方案对代码侵入性太强，最终我们选择维护一个登录请求队列。用上队列的原因在于，在产品需求上经常会有先跳入首页，再从首页跳入二级页的需求，这样能让用户回退一次后，仍然能回到首页。但会导致在不同页面中近乎同时调用 login 方法。在第一种方案中，解决该问题需要获得所有页面实例进行调用。而引入队列后只需要轮询消费队列中函数执行即可。上述流程可解决此问题。伪代码如下：代码仅供理解思路 1let loginDoing = false; 2const loginEvent = []; 3 4const userProfile = observable({ 5  user: { 6    avatar: '', 7    isCompleted: false, 8    nickname: '', 9    uid: 0,10    token: '',11  },12  async loginProcess() {13    if(this.user.token) {14      return this.user;15    }16    loginDoing = true;17    let code;18    try {19      const codeResult = await Taro.login();20      if(codeResult.errMsg !== 'login:ok') {21        throw new Error('Taro.login 失败');22      }23      code = codeResult.code;24    } catch (e) {25      loginDoing = false;26      throw e;27    }28    const result = await post(URL().user.login, {29      code,30    });31    let user = {32      ...result.user,33      token: result.token,34    };35    this.user = user;36    loginDoing = false;37    setTimeout(() => {38      let length = loginEvent.length;39      for(let i = 0; i < length; i++) {40        loginEvent.pop()(user);41      }42    });43    return user;44  },45  login() {46    if(loginDoing) {47      return new Promise((resolve) => {48        loginEvent.push(resolve);49      });50    } else {51      return this.loginProcess()52    }53  },54});复制代码鉴权业务需求中，通常存在某些操作需要 【 用户授权完善信息 】 后才能继续进行，早期项目中都是各自页面中写鉴权代码。因而会涉及大量重复代码，也不利于快速开发。为此我们封装了一套鉴权方案。BasePage通过所有页面基础一个基类 BasePage 。在 BasePage 中写入鉴权逻辑来实现。配合在主页面中使用 AuthorizationModal 组件实现鉴权。代码仅供理解思路1 export default class BasePage extends Component { 2 3    state = { 4        // 鉴权相关 5        showAuthorizationModal: false, 6    }; 7 8    /** 9     * 鉴权相关10     */11    // 授权成功事件12    authSuccessEvent() {13    }1415    // 取消授权事件16    authFailEvent() {17    }1819    async checkAuthorization() {20        // 当前是否有已验证21        let globalData = getGlobalData(STORAGE_KEY.VERIFY);22        if(globalData) {23            return {24                isNew: false,25            };26        } else {27            Taro.showLoading({28                title: '检查授权中...',29                mask: true,30                showTicketModal: false,31            });32            // 如果本地不存在时，先请求接口33            // 未登录过，或新机器34            // 请求token及授权状态35            let res;36            try {37                res = await Taro.login();38            } catch() {39                Toast.fail('登录失败~');40                Taro.hideLoading();41                throw new Error('Taro.login 失败');42            }43            // 请求授权接口44            const result = {};45            if(result.errno === 0) {46                resolve({47                    isNew: false,48                });49            } else {50                // 未授权过51                // 弹窗提示授权52                this.setState({53                    showAuthorizationModal: true,54                });55                this.authSuccessEvent = () => {56                    this.setState({57                        showAuthorizationModal: false,58                    });59                    resolve({60                        isNew: true,61                    });62                };63                this.authFailEvent = () => {64                    this.setState({65                        showAuthorizationModal: false,66                    });67                    reject();68                };69            }70        }71    }72}复制代码页面继承该基类1 class LaunchIndex extends BasePage {}复制代码在页面中置入组件1 {this.state.showAuthorizationModal &&2 <AuthorizationModal onSuccess={this.authSuccessEvent} onFail={this.authFailEvent}/>}3复制代码AuthorizationModal 组件接下来，我们只需要在需要鉴权的操作中如下使用即可1this.checkAuthorization()2  .then((res) => {3   // 授权成功逻辑4       console.log('是否新用户', res.isNew);5   })6   .catch(() => {7    // 授权失败逻辑8    })复制代码该方案好处在于，授权由状态驱动，只需在代码中调用 checkAuthorization 方法即可。AuthorizationView后来，由于第一种方案过于重，对页面代码侵入性较强。为此我们又封装了一套较轻的组件。大部分逻辑中，需要用户主动点击时才进行鉴权，我们基于此思路封装了 AuthorizationView 。对外暴露 onAgree 、 onDeny 方法实现对部分区域的点击鉴权操作。代码仅供理解思路1 class AuthorizationView extends Taro.Component { 2 3  state = { 4    showLoginPanel: false, 5  }; 6 7  /** 8   * 登录 9   */10  click() {11    const { userProfile: { user, }, } = this.props;12    if(user.isCompleted) {13      this.props.onAgree(user);14    } else {15      // 显示登录框16      this.setState({17        showLoginPanel: true,18      });19    }20  }2122  /**23   * 授权登录24   * @param e25   */26  async bindGetUserInfo(e) {27    if(e.detail.errMsg === 'getUserInfo:ok') {28      const { userProfile, } = this.props;29      const userResult = await userProfile.login(true);30      this.setState({31        showLoginPanel: false,32      });33      this.props.onAgree(userResult);34    } else {35      this.props.onDeny();36    }37  }3839  cancel() {40    this.setState({41      showLoginPanel: false,42    });43  }4445  render() {46    return (47      <Block>48        <View onClick={this.click}>{this.props.children}</View>49        {50          this.state.showLoginPanel && <View className='login-panel'>51            <View className='login-panel-main'>52              <View className='login-panel-main-title'>您还未登录</View>53              <View className='login-panel-main-subtitle'>请先登录再进行操作</View>54              <Image className='login-panel-main-image' src='https://p0.ssl.qhimg.com/t01a1e495cc2be1e651.png' />55              <View className='login-panel-main-footer'>56                <View className='login-panel-main-footer-button cancel' onClick={this.cancel.bind(this)}>暂不登录</View>57                <Button className='btn-reset' openType='getUserInfo' onGetUserInfo={this.bindGetUserInfo}>58                  <View className='login-panel-main-footer-button confirm'>立即登录</View>59                </Button>60              </View>61            </View>62          </View>63        }64      </Block>65    );66  }67}6869AuthorizationView.defaultProps = {70  onAgree: () => {71  },72  onDeny: () => {73  },74};7576export default AuthorizationView;77复制代码代码中只需要使用该组件包裹子组件即可使用1 <AuthorizationView onAgree={this.onAgree.bind(this)} onDeny={this.onDeny.bind(this)}>2  <View>生成海报</View>3</AuthorizationView>4复制代码以上两种方案都有在线上业务中使用，具体选型看业务决定优化及Bug追踪在维护阶段，我们会更加关注于用户反馈 bug 时如何复现场景及数据分析。日志收集在小程序基础库版本 2.1.0 后，微信提供了一套日志相关接口：LogManager 。在用户反馈时，通过该接口记录的日志会同步上传至微信后台，可下载查看追踪 Bug。我们通过简单的对其封装，实现一套日志收集机制。1 const _logger = Taro.getLogManager({ level: 0, }); 2 3const Logger = { 4  debug(...args) { 5    _logger.debug(`${dayjs().format('YYYY-MM-DD HH:mm:ss')}", "author": "Rolan", "pub_time": "2019-12-31 00:21", "title": "如何一人五天开发完复杂小程序（前端必看） "}
{"content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。", "author": "admin", "pub_time": "2016-10-12 22:14", "title": "微信小程序开发系列教程第七章：编辑名片页面开发 "}
{"content": "自从2017年微信上线小程序以来，小程序已经迅速成长为一个巨大的生态，吸引各行各业的开发者或服务商参与其中。而由于小程序与线下场景的结合日益紧密，地图类功能已经成为越来越多小程序的“标配”，背后也大部分直接或间接的依赖腾讯位置服务提供的地图能力：如出行利器小程序「摩拜单车」，吃喝玩乐的小程序「美团外卖」，圈粉无数的小程序「玩转故宫」，校园导览类小程序「清华校园导览」，领略大美云南的「游云南」等等。一般来说，如果只是开发一些简单的地图功能，小程序开发者还可以轻松应对；但随着地图应用场景的增多，开发者就可能需要用到比如路线规划、地图选点等比较高级的地图能力，这就需要开发者掌握比较复杂的地图接口，开发难度提升，成本较高。为了帮助开发者“减负”，腾讯位置服务推出了「路线规划」「地图选点」「地铁图」三款小程序插件，帮助开发者5分钟内快速搭建属于你的地图能力！​路线规划插件路线规划插件提供路线规划等功能，根据起终点，多种出行方式智能规划最佳出行路线及详情。开发者可以将路线规划插件嵌入到自建小程序的页面里，实现路线规划功能。1、大数据加持，智能推荐多种出行方案给出用户合理路线规划是最基本功能，而能否通过大数据及实时路况智能呈现更合适的方案，甚至比用户多想一步超出其预期，才是提升产品体验、提高用户粘度的关键。目前路线规划插件可以为用户提供驾车、公交、步行三种出行方式，其中驾车出行方式基于全面的路网信息，结合实时路况，为用户智能提供多种出行方案；公交出行方式也提供了多种公交换乘方案，用户可以根据偏好选择最佳方案。​2、海量公交运营数据，贴心提醒用户合适路线公共交通是出行的主要方式之一，城市里丰富的公共交通资源让我们从A点到B点有太多的选择。路线规划插件的公交方案不仅可以提供多种出行偏好如少步行、时间短、换乘少等供用户选择，而且我们还整合了大量的公交实时运营数据，包括交通管制、运营时间、线路临时更改等等，可以准确告知用户在某个出行的时间内是否有合适的车辆，避免错过公交的尴尬。​地图选点插件地图选点插件可以让用户快速、准确地选择并确认自己的当前位置，并将相关位置信息回传给开发者。同时我们还提供位置检索、关键词分类、POI主子点等辅助功能。1、分类筛选，地点信息精准呈现选点是地图应用中使用频率最高的功能之一。购物时标注收货地址、游玩时寻找附近的餐馆、甚至找银行找医院等等，生活中的方方面面，都需要地图能帮助我们找到一个点或一类点。而我们熟悉的微信发送位置时，经常碰见尴尬的场景是地址列表提供的位置太多，掺杂了我们不需要的地点信息。如何提高用户在地图上选点的体验？告别无效地点信息，地点信息的快速精准呈现才是硬道理！选点插件提供了美食、购物、生活购物、娱乐休闲等多达19个一级分类、452个分类筛选！（详情请了解­­：腾讯地图POI分类关键词）开发者可以根据小程序的使用场景，对地点分类进行设置，同时提供分类筛选，引导用户快速精准选择地点信息。例如，在餐饮类的小程序当中，开发者可以在搜索结果中只展示川菜、湘菜、鲁菜、粤菜等餐馆的分类，而其他类型地点数据则不予展示；同时，用户也可以通过分类筛选快速找到自己想要的地点。​2、地点信息结构化呈现，“主子”关系一目了然想象一下如下场景：“喂喂，我们哪里碰面？”“西直门地铁站”“哪个口？”“我……”对于一个大型的地点信息，往往会包含若干个“子点”。例如上面提到的西直门地铁站，下面会包含若干个出口，相对于西直门地铁站这个“主点”来说，他们就是所谓的“子点”。​选点插件在搜索时提供了目标地点和其相关联的地点信息，用户只需要搜索地点部分内容如“西直门”时，在列表中会展示其相关联的地点信息 “C口（东南口）”“D口（西南口）”等，通过这种结构化呈现的方式，帮助用户快速找到附着在“主点”下的“子点”。地铁图插件当今地铁线路图俨然成为一座城市的符号，如果能在小程序中快速浏览地铁图、查找地铁路线，无疑可以给用户带来极大的便利。地铁图插件可以展示静态的城市地铁线路以及站点信息，同时还提供地铁线路检索、查找最近定位站点信息、站点详情查看等功能。开发者可以将城市地铁图嵌入到自建小程序的页面里，轻松实现地铁图功能。​如何接入​腾讯位置服务提供的小程序插件致力于降低小程序开发者开发地图功能的成本，并且打造完善的小程序地图闭环体验。目前我们已经提供了路线规划、地图选点、地铁图插件产品，其他插件也在陆续的开发中。我们将不断完善扩展插件能力，优化插件使用体验，满足开发者更多的需求，覆盖不同场景下的地图使用需求。现在就来体验「地铁图」「路线规划」「地图选点」微信小程序插件，感受简单快捷的地图服务，只需5分钟，搭建你的小程序地图！同时也欢迎开发者给与我们更多的反馈（QQ群：659847796），如果有好的建议和需求，一定要告诉我们，让我们为开发者提供更多更好的地图插件！", "author": "Rolan", "pub_time": "2019-10-14 00:19", "title": "小程序下找地点、查路线、搜地铁，用这3个插件就够了！ "}
{"content": "本文档 当中所用到的:\r\n\t\tconst $request = this.request\r\n\t\tconst post = $request.call('passport/wxLogin',data)\r\n\t\tpost.then(res=>{}).catch()\r\n\t\t是自己封装的请求方法，如axios，参考时可自行更改\r\n复制代码1、js生成接口请求参数签名加密定义规则：对所有发起请求的参数(包括公共参数)，按key进行升序排序 ，然后组合成key1=value1&key2=value2的形式如： parames = {b:value-b, c:value-c,a:value-a}; 排序后应为： string = \"a=value-a&b=value-b&c=value-c\";排序后对其进行md5: string = md5(string);//注意：这里要过滤掉所有为空的参数，空参数，不传将md5的串与密钥再做一次md5: sign = md5( string + secret ); //sceret为密钥，后端分配/** \r\n * 定义对象排序方法\r\n */\r\nobjectSort(parames) \r\n{ \r\n    var newkeys = Object.keys(parames).sort();\r\n    var newObj = {};\r\n    for(var i = 0; i < newkeys.length; i++) \r\n    {\r\n        newObj[newkeys[i]] = parames[newkeys[i]]; \r\n    }\r\n    return newObj;\r\n}\r\n/** \r\n * 计算签名方法\r\n */\r\nmakeSign(params)\r\n\t{\r\n\t    var sign = '';\r\n\t    var parm = '';\r\n\t    \r\n\t    params = objectSort(params);\r\n\t    for (let i in params)\r\n\t    {\r\n\t        var j = params[i];\r\n\t        parm += i + '=' + j + '&';\r\n\t    }\r\n\t    parm = parm.slice(0,-1);\r\n\t    parm.trim();\r\n\t    \r\n\t    sign = Md5.md5(Md5.md5(parm)+$secret);//$secret为密钥，后端分配 \r\n\t    return sign;\r\n\t},\r\n/** \r\n * 过滤data参数中的空字符\r\n */\t\r\nfilterData(data){\r\n\t\tvar result = {};\r\n\t\tfor (let i in data) \r\n\t\t{\r\n\t\t\tvar value = data[i];\r\n\t\t\tif (typeof (value) == 'undefined') {\r\n\t\t\t\tvalue = '';\r\n\t\t\t}\r\n\t\t\tif(typeof(value) == 'string'){\r\n\t\t\t\tvalue = value.trim();\r\n\t\t\t}\r\n\t\t\tif(value)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result; \r\n\t},\r\n/** \r\n * 构建data参数\r\n */\r\nbulidData(data) {\r\n\t\tif(typeof(data) != 'object'){\r\n\t\t\tdata = {};\r\n\t\t}\r\n\t\t//构建参数\r\n\t\tdata.timestamp = (new Date()).valueOf();\r\n\t\tdata.app_id = Config.app_info.app_id;\r\n\t\t//过滤\r\n\t\tdata = this.filterData(data);\r\n\t\t//检测用户是否登录\r\n\t\tvar token = Helper.user.getToken();\r\n\t\tif(token)\r\n\t\t{\r\n\t\t\tdata.token = token;\r\n\t\t}\r\n\t\tdata.sign = this.makeSign(data);\r\n\t\treturn data;\r\n\t},\r\n复制代码微信登录这里采用 button的开放属性 open-type 触发@getuserinfo事件 获取到code 发送给后台 换取token 存到storge;详细参考微信官方文档<template>\r\n\t<button openType=\"getUserInfo\" lang=\"zh_CN\" @getuserinfo=\"getUserInfo\">授权登录</button>\r\n</template>\r\n\r\n\r\nmethods: {\r\n    getCode(callback) {\r\n    \twx.login({\r\n    \t\tsuccess: res => {\r\n    \t\t\tconsole.log(res);\r\n    \t\t\tif (res.errMsg == 'login:ok') {\r\n    \t\t\t\tif (callback) {\r\n    \t\t\t\t\tcallback(res.code)\r\n    \t\t\t\t}\r\n    \t\t\t\tthis.code = res.code\r\n    \t\t\t}\r\n    \t\t}\r\n    \t});\r\n    },\r\n    getUserInfo(e) {\r\n    \tthis.getCode(code => {\r\n    \t\tif (e.detail.errMsg !== 'getPhoneNumber:ok') {\r\n    \t\t\treturn false;\r\n    \t\t}\r\n    \t\twx.showLoading({\r\n    \t\t\ttitle: '正在登录',\r\n    \t\t\tmask: true\r\n    \t\t});\r\n    \t\tconst data = {\r\n    \t\t\tcode:this.code,\r\n    \t\t\tiv:e.detail.iv,\r\n    \t\t\tencryptedData:e.detail.encryptedData\r\n    \t\t}\r\n    \t\t\r\n    \t\t//发起请求登录\r\n    \t\tconst $request = this.request\r\n    \t\tconst post = $request.call('passport/wxLogin',data)\r\n    \t\tpost.then(res =>{\r\n    \t\t\tconsole.log(res)\r\n    \t\t\tuni.setStorageSync('_user_login_token', res.data.token)\r\n    \t\t}).catch(err => {\r\n    \t\t\t\t//常规catch, 一般不用修改\r\n    \t\t\t\t$request.callError(err)\r\n    \t\t})\r\n    \t});\r\n    }\r\n}\r\n复制代码微信小程序支付首先获取code{uni.login()} 然后调后台接口 把code和订单好传给后台，后台 返回的数据就是小程序调支付的参数{uni.requestPayment()} 就这么简单const $request = this.request\r\nconst resLogin = await uni.login()\r\nif (resLogin[0] !== null || resLogin[1].errMsg !== 'login:ok') {\r\n\treturn uni.showToast({\r\n\t\ttitle: 'code获取失败',\r\n\t\ticon: 'none'\r\n\t})\r\n}\r\nconst code = resLogin[1].code\r\n\r\nconst post = $request.call('order/doPay', {\r\n\torder_id: this.order_id,\r\n\tpay_type: '无忌微信小程序支付',\r\n\tcode: code\r\n})\r\npost.then(data => {\r\n\t// 返回数据，只返回接口中的data\r\n\tconst result = JSON.parse(data.data.pay_data)//字符串转对象\r\n\tuni.requestPayment({\r\n\t\tprovider: 'wxpay',\r\n\t\ttimeStamp: result.timeStamp,\r\n\t\tnonceStr: result.nonceStr,\r\n\t\tpackage: result.package,\r\n\t\tsignType: result.signType,\r\n\t\tpaySign: result.paySign,\r\n\t\tsuccess: res => {\r\n\t\t\tconsole.log('success:' + JSON.stringify(res))\r\n\t\t\tthis.requestDetail()\r\n\t\t},\r\n\t\tfail: err => {\r\n\t\t\tconsole.log('fail:' + JSON.stringify(err))\r\n\t\t}\r\n\t})\r\n}).catch(function(e) {\r\n\t//常规catch, 一般不用修改\r\n\t$request.callError(e)\r\n复制代码4、H5支付(微信内浏览器/JSPAI)获取code在登录时就获取code，后台得到openId将其存起来，之后后台在用到openId的地方就不用再获取了（不会过期）getCode(){\r\n\tlet appid = {appid}\r\n\tlet redirect_uri = encodeURIComponent({url})//回调页面地址\r\n\twindow.location.href = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=\" + appid + \"&redirect_uri=\" + redirect_uri + \"&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\"\r\n}\r\n复制代码封装H5支付代码**\r\n * 支付\r\n * 这里的 $request.call()为自己封装的请求方法，使用时请自行更改\r\n */\r\nvar payH5 = {\r\n\tonBridgeReady: function(url, $params,success) {\r\n\t\tconst post_H5 = $request.call(url, $params)\r\n\t\tpost_H5.then(data => {\r\n\t\t\t// 返回数据，只返回接口中的data\r\n\t\t\tconst result_H5 = JSON.parse(data.data.pay_data)//后台返回的数据为字符串，转换对象\r\n\t\t\tWeixinJSBridge.invoke(\r\n\t\t\t\t'getBrandWCPayRequest', {\r\n\t\t\t\t\t\"appId\": result_H5.appId, //公众号名称，由商户传入\r\n\t\t\t\t\t\"timeStamp\": result_H5.timeStamp, //时间戳，自1970年以来的秒数\r\n\t\t\t\t\t\"nonceStr\": result_H5.nonceStr, //随机串     \r\n\t\t\t\t\t\"package\": result_H5.package,\r\n\t\t\t\t\t\"signType\": result_H5.signType, //微信签名方式：     \r\n\t\t\t\t\t\"paySign\": result_H5.paySign //微信签名 \r\n\t\t\t\t},\r\n\t\t\t\tfunction(res) {\r\n\t\t\t\t\tif (res.err_msg == \"get_brand_wcpay_request:ok\") {\r\n\t\t\t\t\t\tvar msg = '支付成功';\r\n\t\t\t\t\t\tsuccess(msg)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar msg = '支付失败';\r\n\t\t\t\t\t\tsuccess(msg)\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t}).catch(function(e) {\r\n\t\t\t//常规catch, 一般不用修改\r\n\t\t\t$request.callError(e)\r\n\t\t})\r\n\t},\r\n\r\n\tdoPay(url, $params,success) {\r\n\t\tif (typeof WeixinJSBridge == \"undefined\") {\r\n\t\t\tif (document.addEventListener) {\r\n\t\t\t\tdocument.addEventListener('WeixinJSBridgeReady', this.onBridgeReady, false);\r\n\t\t\t} else if (document.attachEvent) {\r\n\t\t\t\tdocument.attachEvent('WeixinJSBridgeReady', this.onBridgeReady);\r\n\t\t\t\tdocument.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.onBridgeReady(url, $params,success)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default payH5\r\n复制代码支付调用将这个文件引入需要的页面或者挂载到vue原型上（这里以uni-app中介绍）在main.js中 引入： \r\n\t\t\t\timport H5Pay from './api/h5Pay.js'\r\n\t\t\t\tVue.prototype.H5Pay = H5Pay\r\n\r\n页面引用:\r\n\r\n\t\t\tthis.H5Pay.doPay(url,params,callback)\r\n参数：\t \t  url:接口请求地址\r\n\t\t\tparams：请求参数\r\n\t\t\tcallback:回调方法（回调支付结果）\r\n\r\nH5pay(){\r\n\tthis.H5Pay.doPay('order/doPay', {\r\n\t\t\t\t\torder_id: order_id,//订单号\r\n\t\t\t\t\tpay_type: '',//支付方式\r\n\t\t\t\t}, function(msg) {\r\n\t\t\t\t\tuni.showToast({\r\n\t\t\t\t\t\ttitle: msg,\r\n\t\t\t\t\t\ticon:'none'\r\n\t\t\t\t\t})\r\n\t\t\t\t\tuni.navigateBack()\r\n\t\t\t\t})\r\n}\r\n复制代码5、H5支付（非微信内置浏览器）相对来说前端简单很多，没什么麻烦要求 后台会返回一个mwev_url ，window.location.href = mwev_url + redirect_uri （这里的redirect_uri 是重定向的页面地址，域名要和支付域名一致 ！！！做编译encodeURIComponent(url)）dopayWeb() { //非微信浏览器支付\r\n\tconst $request = this.request;\r\n\tconst post = $request.call('order/doPay', {\r\n\t\torder_id: this.order_id,//订单号\r\n\t\tpay_type: 'nweb'//支付方式\r\n\t});\r\n\tpost.then(res => {\r\n\t\tconsole.log(res);\r\n\t\tlet url = res.mwev_url\r\n\t\tlet redirect_uri = encodeURIComponent(url)\r\n\t\twindow.location.href = url + \"&redirect_uri=\" + redirect_uri \r\n\t}).catch(function(e) {\r\n\t\t$request.callError(e)\r\n\t});\r\n},\r\n复制代码6、 区分是否是微信内置浏览器function isMicroMessenger() {\r\n    let result = false;\r\n    let userAgent = window.navigator.userAgent;    \r\n    if(userAgent.indexOf('MicroMessenger') > -1) {\r\n        result = true;\r\n    }\r\n    return result;\r\n}\r\n复制代码", "author": "Rolan", "pub_time": "2019-10-22 00:55", "title": "微信小程序登录、支付（小程序、微信H5、非微信H5）即请求加密方法 ... "}
{"content": "本文作者：韩永刚，360奇舞团 WEB前端开发高级工程师。本文将简单介绍一下持续集成的概念，并手把手带你在你的微信小程序项目中完成属于你的持续集成方案。什么是前端工程化所有能降低成本，并且能提高效率的事情总称为工程化。在前端项目中能够减少重复工作、扩展 javascript\\html\\css 本身的语言能力、解决功能复用和变更问题、解决开发和产品环境差异问题、任何时间任何地点生成可部署的软件、解决发布流程问题，都属于前端工程化。什么是持续集成持续集成是前端工程化中的一部分，是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括自动化编译，自动化测试，自动化发布）来验证项目代码，从而尽早地发现错误。Web项目持续集成怎么做Web项目的持续集成方案选择比较多，并且相对成熟，这里介绍一下 gitlab-ci 持续集成方案。这种方式的原理就是为项目在自己的 linux 服务器安装并注册 gitlab-runner，注册会有一个 token ，服务器上运行 gitlab-runner 后， runner 会轮询的发送带 token 的 http 请求给 gitlab ,如果 gitlab 有任务了，（一般是 git push ），那么会把任务信息返回给 runner ，然后 runner 就开始调用注册时选的 Executor 来执行项目根目录下的配置文件 .gitlab-ci.yml ，执行后把结果反馈给 gitlab 。此时我们可以编写 .gitlab-ci.yml 脚本，比如设定当 test 分支发生 push时，自动运行测试用例、自动构建代码、自动将代码更新到测试人员在测的环境等任何你想在提测时需要做的事情。当 merge 到 master 时，自动更新线上代码完成上线等各种你想在上线时做的事情。这里只要考虑的足够全面，那么之后的项目开发你只需要 push 到对应的分支， gitlab-runner 会自动完成你想做的所有构建、提测、上线操作。减少重复工作，这就是持续集成的意义所在。手把手教你完成小程序的持续集成方案小程序的持续集成可以继续使用 gitlab-ci 的方式，但由于小程序的构建、提测、提交体验版等操作都需要依赖于 微信开发者工具 ，而微信开发者工具只有 Windows 和 Mac 版，所以我们需要一台 Windows 服务器来运行 gitlab-runner 。1. 准备工作一台 Windows 服务器一个权限为 Maintainer 的 gitlab 项目2. 安装必要软件在这台 Windows 服务器上安装以下软件GitNode.js微信开发者工具3. 配置gitlab-runner1. 首先下载 gitlab-runnerhttps://docs.gitlab.com/runner/install/windows.html\r\n下载完成后将其移动到合适的路径后重命名为 gitlab-runner.exe2. 在 Windows 服务器中打开 powershell 并进入 gitlab-runner.exe 所在目录，然后执行以下命令.\\gitlab-runner.exe register1. Please enter the gitlab-ci coordinator URL打开想要设置 CI 的 gitlab 项目，进入页面 settings > CI/CD > Runners > Expand ，找到 Set up a specific Runner manually ，输入 Specify the following URL during the Runner setup: 下的地址2. Please enter the gitlab-ci token for this runner输入 Use the following registration token during setup: 下的token字符串3. Please enter the gitlab-ci description for this runner输入一个描述4. Please enter the gitlab-ci tags for this runner输入一个标签，该标签对应该runner5. Please enter the executor这里输入 shell 就好此时刷新 gitlab 页面会新增一个 gitlab-runner3. 执行命令 install.\\gitlab-runner.exe install4. 执行命令 start.\\gitlab-runner.exe start此时刷新 gitlab 页面，之前的 gitlab-runner 会更新为以下状态，表示 gitlab-runner 配置完成，已经可以开始工作。4. 修改gitlab-runner服务的登录账号由于 gitlab-runner 服务默认登录账号为 authority\\system ，而这个账号在执行微信开发者工具命令行时会出现报错，所以我们需要更改 gitlab-runner服务的登录账号为正确账号并重启该服务。右击计算机 -> 管理 -> 服务和应用程序 -> 服务找到 gitlab-runner 服务右击 gitlab-runner -> 属性 -> 登录 -> 此账号 -> 输入可以正确使用微信开发者工具命令行的账号和密码 -> 确定 -> 重启动此服务修改完成后账号会正确被更改5. 配置微信开发者工具使用你的微信账号登录开发者工具设置 -> 安全 -> 服务端口 -> 开启6. 配置.gitlab-ci.yml在项目根目录创建 .gitlab-ci.yml 文件，并填写以下配置。stages: # 定义阶段用于执行任务\r\n  - build\r\n  - deploy\r\n\r\nbuild_job: # 定义 build 任务，名称可以随意命名，只是为了方便理解和区分\r\n  stage: build # 该任务属于 build 阶段，要严格与stages中定义的命名一致\r\n  only:\r\n    - master\r\n  tags: # tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配\r\n    - mp_win7\r\n  before_script: # 执行script之前的钩子\r\n    - whoami\r\n  script: # 执行下面脚本，这里可以自定义配置您的构建任务\r\n    - echo \"build\" # 可以在这里执行您项目的构建编译操作\r\n\r\ndeploy_job: # 定义 deploy 任务，名称可以随意命名，只是为了方便理解和区分\r\n  stage: deploy # 该任务属于 deploy 阶段\r\n  only:\r\n    - master\r\n  tags: # tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配\r\n    - mp_win7\r\n  script: # 执行下面脚本，这里可以自定义配置您的部署任务\r\n    - C:\\software\\wechatDevTool\\cli.bat -u 0.1.0@\"$PWD\" --upload-desc 最新的描述 # 这里使用微信开发者工具提供的命令行工具进行上传体验版操作修改完成后将代码 push 到远程仓库，会自动触发CI任务。此时登录微信小程序官网后台，就可以看到刚刚 push 代码时由 gitlab-ci 自动上传的体验版了。有关 .gitlab-ci.yml 的详细配置方法可以参考以下文章。http://urlqh.cn/mK3tA\r\nhttp://urlqh.cn/mNjWs\r\n7. 持续集成项目方案以下为本人最近在做的 360瞭望台 小程序的持续集成方案，您可以根据自己的需要加以改进，并完成属于你的持续集成方案。由于编写 .gitlab-ci.yml 时需要用到微信开发者工具的命令行，所以为了便于团队成员使用，我开发了一个 node.js 脚本，并发布为 npm 模块，用于在 .gitlab-ci.yml 调用 Windows 虚拟机中的上传命令。约定团队开发流程，开发新需求时创建 feature/0.5.1 (需求版本号) 分支，当 push 代码时会自动触发 CI 任务，并在虚拟机修改为 test 环境后提交体验版。发完测试报告后可以将小程序提审时，我们需要将 feature/0.5.1 分支 merge 到 audit 分支，此时会自动触发 CI 任务，并在虚拟机修改为 production 环境后提交体验版。 audit 分支需要添加为受保护的分支，不允许直接 push 代码，如果审核没通过那么可以以 audit 为基础新建 feature/0.5.2 分支进行调整后重新 merge 到 audit 。当审核通过后我们需要将 audit 分支代码合并到 master 分支， master 分支应该永远与线上代码保持同步。相关资料http://urlqh.cn/mKi7T\r\nhttp://urlqh.cn/mJPCC\r\nhttp://urlqh.cn/mIWRk\r\nhttp://urlqh.cn/mJoY2\r\nhttp://urlqh.cn/mLCIB", "author": "Rolan", "pub_time": "2019-11-1 00:52", "title": "微信小程序工程化之持续集成方案 "}
{"content": "本文为uniapp中picker组件“确定”和“取消”文字的修改的教程，包括颜色和文字，需要清楚的是，颜色在H5和微信小程序下非常容易修改，但是“确定”和“取消”文字是无法修改的，因为在uniapp中这些都是写死在uniapp源码中的，目前没有找到更好的方式去修改！前言首先需要确定的几点* 在uniapp中picker组件是webview（无论是小程序还是APP，h5是dom）* 需要清楚自己需要修改的是什么版本的，H5和APP以及小程序不一样* 是需要修改文字还是颜色* 没有源码阅读能力者请谨慎操作H5修改颜色非常方面，但是修改文字目前只能改uniapp源码* 修改文字，找到你安装HBuilderX的目录D:\\Program Files\\HBuilderX\\plugins\\uniapp-cli\\node_modules\\@dcloudio\\uni-h5\\src\\platforms\\h5\\view\\components\\picker\\index.vue\r\n// D:\\Program Files为你安装的HBuilderX目录\r\n// 在index.vue中16-25行代码中\r\n\r\n        <div\r\n          class=\"uni-picker-header\"\r\n          @click.stop>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-cancel\"\r\n            @click=\"_cancel\">取消</div>\r\n          <div\r\n            class=\"uni-picker-action uni-picker-action-confirm\"\r\n            @click=\"_change\">确定</div>\r\n        </div>修改颜色，可以直接在上面的index.vue里面修改，但是这样做会带来一个问题，就是每次升级HBuilderX的时候就需要修改这个文件// 在index.vue中550-558行代码中\r\n.uni-picker-container .uni-picker-action.uni-picker-action-cancel {\r\n  float: left;\r\n  color: #888;\r\n}\r\n\r\n.uni-picker-container .uni-picker-action.uni-picker-action-confirm {\r\n  float: right;\r\n  color: #007aff;\r\n}在App.vue中修改颜色uni-picker .uni-picker-action.uni-picker-action-confirm{color: #FF725C;}App和小程序在app和小程序中 H5版本的修改方法全部失效修改文字// 在D:\\Program Files\\HBuilderX\\plugins\\weapp-tools\\template\\common\\__uniapppicker.html\r\n// 第 5562-5577是“取消”和“确定”的文字\r\n}, [t._v('取消')]), e(\"div\", {\r\n    staticClass: \"uni-picker-action uni-picker-action-confirm\",\r\n    on: {\r\n    click: t._change\r\n    }\r\n}, [t._v('确定')])]), t.visible ? e(\"picker-view\", {\r\n    staticClass: \"uni-picker-content\",\r\n    attrs: {\r\n    value: t.valueArray\r\n},\r\n    on: {\r\n    \"update:value\": function(i) {\r\n        t.valueArray = i\r\n    }\r\n}\r\n},修改样式// 第14行css代码中\r\n.uni-picker-action.uni-picker-action-cancel[data-v-1c1d4578]{float:left;color:#888} // 取消\r\n.uni-picker-action.uni-picker-action-confirm[data-v-1c1d4578]{float:right;color:#57DBD0} //确定注意事项此方法在升级更新HBuilderX里面的文件就会重置，请注意再次修改，最好把自己项目需要修改的文件修改后备份", "author": "Rolan", "pub_time": "2019-11-11 00:45", "title": "uni-app中picker组件“确定”和“取消”文字的修改 "}
{"content": "项目介绍当代大学生上课缺少积极性，学习缺乏效率。同为大学生的我深有体会。所以特别开发出这样一款学习类的微信小程序帮助学生进行学习、巩固知识，同时增加对战PK模块来加强学生们的学习积极性。这是一个为学生提供在线学习课程、题库练习、考试答题、做题PK、上课签到、资料查阅、成绩分析等功能的微信小程序希望大佬们走过路过给个star~技术选型前端：Taro + 微信小程序 + Echarts后端：Node.js + MySql + websocket其他：七牛云存储项目功能在线学习课程专项题库练习课程考试答题知识趣味竞赛上课签到系统专业资料查阅学生成绩分析运行截图1. 主页2. 个人中心3. 课程详情4. 做题练习5. 学习交流群6. 聊天室7. 课程列表8. 习题列表9. 排行榜10. 论坛项目分析项目采用前后端分离的技术，前端采用了Taro微信小程序框架，因为本人比较喜欢React，所以采用了Taro这款类React语法的框架，后端则采用了Node.js,koa2框架。聊天室页面采用websocket来进行连接今天，我们首先来聊一聊聊天室使用的小技巧（并不）首先我们的后端数据库采用的是mysql，我们建了一个聊天记录的表（萌新勿喷~）1. 后端部分数据库部分我们将所有的聊天记录存放到一张表上方便管理，因为我们有多个聊天群组，我们该如何区分这些不同的聊天群组呢？答案是，通过room_name来区分，获取聊天记录的时候就直接查询这个群组名即可，这样就不用开很多的表，将不同的群聊记录存放到不同的表中啦！同时因为我们的聊天记录内需要存储emoji等信息，所以，我们需要将数据库的字符集调整为 utf8mb4 -- UTF-8 Unicode ，排序规则选择 utf8mb4_unicode_ci ，这个可以通过自行百度，或者navicat中设置。然后我们将数据表以及字段类型也设置为 utf8mb4 ，便于存储emoji信息后端处理聊天记录的方法。router.get('/chatlog/:to', async (ctx) => {\r\n  const to = ctx.params.to\r\n  const response = []\r\n  const res = await query(`SELECT * FROM chatlog WHERE room_name = '${to}' ORDER BY current_time DESC`);\r\n  res.map((item, index) => {\r\n    const { room_name, user_name, user_avatar, current_time, message } = item\r\n    response[index] = {\r\n      to: room_name,\r\n      userName: user_name,\r\n      userAvatar: user_avatar,\r\n      currentTime: formatTime(current_time),\r\n      message,\r\n      messageId: `msg${current_time}${Math.ceil(Math.random() * 100)}`\r\n    }\r\n  })\r\n  ctx.response.body = parse(response)\r\n})这是获取指定群聊的后端接口，to代表的是群组名，使用get的方法即可获取到指定群聊的聊天记录啦！继续聊聊我们如何为所有连接到聊天室的网友们发送信息，这里我们采用的是广播的方式，不同于socket.io内已经封装好广播的方法，小程序规定只能使用websocket，所以我粗略的封装了一下广播（十分丑陋的代码）let onlineUserSocket = {}\r\nlet onlineUserInfo = {}\r\n\r\nconst handleLogin = (ws, socketMessage) => {\r\n  const { socketId, userName, userAvatar } = socketMessage\r\n  onlineUserSocket[socketId] = ws\r\n  onlineUserInfo[socketId] = { userName, userAvatar }\r\n  ws.socketId = socketId\r\n}\r\n\r\n// 广播消息\r\nconst broadcast = (message) => {\r\n  const { from, userName } = message\r\n  Object.values(onlineUserSocket).forEach((socket) => {\r\n    socket.send(JSON.stringify({\r\n      ...message,\r\n      isMyself: userName === onlineUserInfo[socket.socketId].userName\r\n    }))\r\n  })\r\n}我们再登录的时候，就将前端传来的消息存入对象中，以及他的socket对象，然后广播的时候就可以遍历所有的socket对象，为所有在线用户广播消息，其中的 isMyself 代表的是否为本人，例如我发的消息，自己的socket对象接受广播的时候就是 true 。别人的就是 false ，这样做是为了方便区分，自己的聊天消息和被人的聊天消息2. 前端部分接下来聊聊前端的聊天室部分handleSocketMessage(): void {\r\n    const { socketTask } = this\r\n    socketTask.onMessage(async ({ data }) => {\r\n      const messageInfo: ReceiveMessageInfo = JSON.parse(data)\r\n      const { to, messageId, isMyself, userName, userAvatar, currentTime, message } = messageInfo\r\n      const time: string = formatTime(currentTime)\r\n\r\n      this.messageList[to].push({\r\n        ...messageInfo,\r\n        currentTime: time\r\n      })\r\n      /* 设置群组最新消息 */\r\n      this.contactsList.filter(contacts => contacts.contactsId === to)[0].latestMessage = {\r\n        userName, message, currentTime: time\r\n      }\r\n      this.scrollViewId = isMyself ? messageId : ''\r\n      await Taro.request({\r\n        url: 'http://localhost:3000/chatlog',\r\n        method: 'PUT',\r\n        data: {\r\n          to,\r\n          userName,\r\n          userAvatar,\r\n          currentTime,\r\n          message,\r\n        }\r\n      })\r\n    })\r\n  }我们先接受消息，然后先更新指定群组名的聊天群组的聊天记录，然后再使用 PUT 的方式访问接口添加聊天记录到数据库中。可以看到我们的聊天记录是分为左边以及右边的，自己发的消息即为右边，我们可以通过简单的flex布局来实现// 这里是覆盖默认样式，显示自己消息的样式\r\n.myself {\r\n  justify-content: flex-end;\r\n\r\n  .avatar {\r\n    order: 1;\r\n  }\r\n\r\n  .info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-end;\r\n\r\n    .header {\r\n      justify-content: flex-end;\r\n\r\n      .username {\r\n        order: 1;\r\n        margin-right: 0 !important;\r\n        margin-left: .5em;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      color: #333 !important;\r\n      border: #e7e7e7 1px solid;\r\n      background: #fff !important;\r\n      box-shadow: 0 8px 20px -8px #d7d7d7;\r\n    }\r\n  }\r\n}\r\n\r\n// 以下是默认样式，就是左边的样式\r\n.message-wrap {\r\n  display: flex;\r\n  margin: 20px 0;\r\n\r\n  .avatar {\r\n    width: 14vw;\r\n    height: 14vw;\r\n    margin: 10px;\r\n    border-radius: 50%;\r\n    background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);\r\n  }\r\n\r\n  .info {\r\n\r\n    .header {\r\n      display: flex;\r\n      align-items: center;\r\n      max-width: 40vw;\r\n      padding: 10px 0;\r\n      color: #666;\r\n      font-size: .8em;\r\n\r\n      .username {\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n        max-width: 40vw;\r\n        margin-right: .5em;\r\n        color: #555;\r\n        font-size: 1.2em;\r\n        font-weight: bold;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      display: inline-block;\r\n      max-width: 60vw;\r\n      padding: 10px 20px;\r\n      color: #fff;\r\n      word-break: break-all;\r\n      border-radius: 20px;\r\n      background: #66a6ff;\r\n    }\r\n  }\r\n}最后我们聊一下websocket的断线重连handleSocketClose(): void {\r\n    const { socketTask } = this\r\n    socketTask.onClose((msg) => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('onClose: ', msg)\r\n    })\r\n  }\r\n\r\n  handleSocketError(): void {\r\n    const { socketTask } = this\r\n    socketTask.onError(() => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('Error!')\r\n    })\r\n  }我们这里先监听一下websocket关闭或者异常的情况，调用重连方法，以及清空socketTask的对象，接下来是重连的方法socketConnect() {\r\n    // 生成随机特有的socketId\r\n    this.generateSocketId()\r\n\r\n    /* 使用then的方法才能正确触发onOpen的方法，暂时不知道原因 */\r\n    Taro.connectSocket({\r\n      url: 'ws://localhost:3000',\r\n    }).then(task => {\r\n      this.socketTask = task\r\n      this.handleSocketOpen()\r\n      this.handleSocketMessage()\r\n      this.handleSocketClose()\r\n      this.handleSocketError()\r\n    })\r\n  }\r\n\r\n  socketReconnect(): void {\r\n    this.isReconnected = true\r\n    clearTimeout(this.timer)\r\n\r\n    /* 3s延迟重连，减轻压力 */\r\n    this.timer = setTimeout(() => {\r\n      this.socketConnect()\r\n    }, 3000)\r\n  }我们每三秒调用一遍socket连接的方法，重新再设置好socketId，以及socketTask，重新监听各种方法。这里有一个奇特的地方，就是Taro的connectSocket方法，不能使用 async/await 的方法来获取socketTask，也就是说不能这样 const socketTask = await Taro.connectSocket({...}) 来获取socketTask，只能通过then的方法才能获取到，卑微的我暂时不知道如何解决这个问题......具体后续请关注一下我的github，将持续更新项目！猛戳~", "author": "Rolan", "pub_time": "2019-11-19 00:41", "title": "使用Taro小程序框架开发一个学习做题聊天交流的微信小程序 "}
{"content": "在开始前，你需要准备：注册微信小程序一个简单的springBoot 项目微信开发者工具正式微信小程序发送消息主要通过WxMaTemplateMessage 类来推送public class WxMaTemplateMessage implements Serializable {\r\n    private String toUser;       // 给谁推送(用户openId)\r\n    private String templateId;  // 消息ID\r\n    private String page;    // 用户点开消息跳转到对应的小程序界面\r\n    private String formId;  // 表单formId\r\n    private List<WxMaTemplateData> data; // 消息的数据列表\r\n    private String emphasisKeyword;  \r\n...\r\n复制代码所以我们在推送前需要构造这些信息，formId 和toUser(openId) 是从前端传过来的。formId 可以通过表单或者支付来获取，表单比较简单，只需要把report-submit 设置为true 就可以获得。简单通过微信开发者工具来获取formId(openId 数据库存了)先建立一个前端项目，AppID 就是小程序的id，在微信公众号后台可以看到。修改index/index.js 和index.wxml (百度某位同学的)，通过表单来获取formId ，并发送到后台。// index.wxml\r\n<form bindsubmit='registerFormSubmit' report-submit='true'>\r\n  <view class='buttons'>\r\n    <button class='confirmbtn' form-type='submit'>确定</button>\r\n  </view>\r\n\r\n</form>\r\n<view>formid： {{formid}}</view>\r\n<button bindtap='push'>\r\n    发送\r\n</button>\r\n\r\n复制代码//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  \r\n  data: {\r\n    formid: \"\"\r\n  },\r\n  //事件处理函数\r\n  registerFormSubmit: function (e) {\r\n    //    打印formId\r\n    console.log(e.detail.formId);\r\n    this.setData({\r\n      formid: e.detail.formId\r\n    })\r\n   },\r\n  //测试推送\r\n push() {\r\n    let formid = this.data.formid;\r\n   let openid = 'oT-H-40ZHdRX1REZFKQhPg3jJZoQ';\r\n    wx.request({\r\n      url: 'http://localhost:8080/push?openId=' + openid + \"&formId=\" + formid,\r\n      success(res) {\r\n        console.log(\"推送结果：\", res)\r\n      },\r\n      fail(err) {\r\n        console.log(\"推送失败：\", err)\r\n      }\r\n    })\r\n  }\r\n})\r\n\r\n复制代码这里formid 在测试的时候获取不到，调到真机调试，或者用预览就行了。请求后台接口来发送消息（ctrl c v 百度某同学）import cn.binarywang.wx.miniapp.api.WxMaService;\r\nimport cn.binarywang.wx.miniapp.api.impl.WxMaServiceImpl;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateData;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateMessage;\r\nimport cn.binarywang.wx.miniapp.config.WxMaInMemoryConfig;\r\nimport me.chanjar.weixin.common.error.WxErrorException;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@RestController\r\npublic class PushController {\r\n\r\n    @GetMapping(\"/push\")\r\n    public String push(@RequestParam String openId, @RequestParam String formId) {\r\n        //1,配置小程序信息\r\n        WxMaInMemoryConfig wxConfig = new WxMaInMemoryConfig();\r\n        wxConfig.setAppid(\"你的appId\");\r\n        wxConfig.setSecret(\"你的secret\");\r\n\r\n        WxMaService wxMaService = new WxMaServiceImpl();\r\n        wxMaService.setWxMaConfig(wxConfig);\r\n\r\n        //2,设置模版信息（keyword1：类型，keyword2：内容）\r\n        List<WxMaTemplateData> templateDataList = new ArrayList<>(2);\r\n        WxMaTemplateData data1 = new WxMaTemplateData(\"keyword1\", \"获取老师微信\");\r\n        WxMaTemplateData data2 = new WxMaTemplateData(\"keyword2\", \"2501902696\");\r\n        WxMaTemplateData data3 = new WxMaTemplateData(\"keyword3\", \"2501902696\");\r\n        WxMaTemplateData data4 = new WxMaTemplateData(\"keyword4\", \"2501902696\");\r\n        templateDataList.add(data1);\r\n        templateDataList.add(data2);\r\n        templateDataList.add(data3);\r\n        templateDataList.add(data4);\r\n\r\n        //3，设置推送消息\r\n        WxMaTemplateMessage templateMessage = WxMaTemplateMessage.builder()\r\n                                                  .toUser(openId)\r\n                                                  .formId(formId)\r\n                                                  .templateId(\"你的消息id\") // 在微信公众号后台可以申请消息模版\r\n                                                  .data(templateDataList)\r\n                                                  .page(\"pages/index/index\")\r\n                                                  .build();\r\n\r\n        //4，发起推送\r\n        try {\r\n            wxMaService.getMsgService().sendTemplateMsg(templateMessage);\r\n        } catch (WxErrorException e) {\r\n            System.out.println(\"推送失败：\" + e.getMessage());\r\n            return e.getMessage();\r\n        }\r\n        return \"推送成功\";\r\n    }\r\n\r\n}\r\n复制代码", "author": "Rolan", "pub_time": "2019-11-27 00:45", "title": "微信小程序推送消息简单Demo "}
{"content": "随着今年的双十一落下帷幕，京喜（原京东拼购）也迎来了首捷。双十一前夕微信购物一级入口切换为京喜小程序，项目顺利通过近亿级的流量考验，在此与大家分享一点自己参与的工作。在接手项目前，京喜业务已在线上稳定运行较长时间。但经过一段时间迭代维护后，发现首页存在以下问题：H5 版本首页针对不同渠道开发了多套页面，对开发者维护和内容运营来说存在较大挑战，需投入大量人力成本；项目技术栈不统一，分别有传统 H5 开发、原生小程序开发、wqVue 框架开发，严重影响项目复杂度，迭代过程苦不堪言；H5、小程序以及 RN 三端存在各自构建和发布流程，涉及较多工具及复杂系统流程，影响业务交付效率。综上所述，京喜迎来一次改版契机。改版目标从前端角度来看，本次改版要实现以下目标：升级并统一项目技术栈，解决项目技术栈混乱的现状；使用一套代码，适配微信入口、手 Q 入口、微信小程序、京东 APP、京喜 APP、M 站六大业务场景，减少多套页面的维护成本，提升交付效率；通过让 RN 技术在业务上的落地，完善团队在 App 端的技术储备；优化页面性能及体验，为下沉市场用户提供优质的产品体验；技术选型京喜业务拥有非常丰富的产品形态，涵盖了 H5、微信小程序以及独立 APP 三种不同的端，对支持多端的开发框架有着天然的需求。在技术选型上，我们选择团队自研的 Taro 多端统一开发解决方案。Taro 是一套遵循 React 语法规范的多端开发解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。选它有两个原因，一来是 Taro 已经成熟，内部和外部都有大量实践，内部有京东 7FRESH、京东到家等，外部有淘票票、猫眼试用等多个案例，可以放心投入到业务开发；二来团队成员都拥有使用 Taro 来开发内部组件库的经验，对业务快速完成有保障。开发实录由于首页改版的开发排期并不充裕，因此充分地复用已有基础能力（比如像请求、上报、跳转等必不可少的公共类库），能大量减少我们重复的工作量。话虽如此，但在三端统一开发过程中，我们仍遇到不少问题同时也带来解决方案，以下我们一一阐述。H5 篇我们所有的页面都依赖现有业务的全局公共头尾及搜索栏等组件，这就不可避免的需要将 Taro 开发流程融入到现有开发和发布流程中去。同时公共组件都是通过 SSI 的方式引入和维护的，为了能在运行 npm run dev:h5 时预览到完整的页面效果，需要对 index.html 模版中的 SSI 语法进行解析， index.html 模版文件代码结构大致如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\">\r\n  <title>京喜</title>\r\n  <!--#include virtual=\"/sinclude/common/head_inc.shtml\"-->\r\n</head>\r\n<body>\r\n  <div id=\"m_common_header\" style=\"display:none;\"></div>\r\n  <!--S 搜索框-->\r\n  <div id=\"search_block\" class=\"search_block\"></div>\r\n  <div id=\"smartboxBlock\" style=\"display:none;\"></div>\r\n  <!--E 搜索框-->\r\n  <div id=\"app\" class=\"wx_wrap\"></div>\r\n  <!--#include virtual=\"/sinclude/common/foot.shtml\"-->\r\n</body>\r\n</html>\r\n复制代码可以看到模版中存在很多类似 <!--#include virtual=\"...\" --> 格式的代码，这些就是通过 SSI 方式引入的 H5 公共组件，它的 virtual 属性指向的文件不存在于本地而是存在于服务器上的，所以我们遇到的第一个问题就是在本地解析这些文件，确保能预览到完整的页面效果，不然开发调试起来就非常的低效。好在 Taro 有暴露出 webpack 的配置，我们可以通过引入自定义加载器（这里就叫 ssi-loader ）来解析这些代码的路径，然后请求服务器上的文件内容并进行替换即可，要实现这个功能只需在项目的 config/dev.js 中加入如下代码即可：module.exports = {\r\n  h5: {\r\n    webpackChain(chain, webpack) {\r\n      chain.merge({\r\n        module: {\r\n          rule: {\r\n            ssiLoader: {\r\n              test: /\\.html/,\r\n              use: [\r\n                {\r\n                  loader: 'html-loader'\r\n                },\r\n                {\r\n                  loader: 'ssi-loader',\r\n                  options: {\r\n                    locations: {\r\n                      include: 'https://wqs.jd.com'\r\n                    }\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n复制代码这样就解决了本地开发调试难点，然后开开心心的进行页面开发。当页面开发完成之后，接下来遇到的问题就是如何将前端资源部署到测试和生产环境。由于现有开发和发布流程都是基于内部已有的平台，我们临时定制一套也不太现实，所以需要将它融入到 Taro 的流程中去，这里我们引入了 gulp 来整合各种构建和发布等操作，只要构建出符合发布平台规范的目录即可利用它的静态资源构建、版本控制及服务器发布等能力，这样我们就打通了整个开发和发布流程。这套拼凑起来的流程还存在不少的问题，对于新接手的同学有一点小繁琐，有着不少改善的空间，这也是接下来的重点工作方向。另外 Taro 的 H5 端之前是基于 SPA 模式，对于有着多页开发需求的项目来说不太友好，当时反馈给 Taro 团队负责 H5 的同学，很快得到了响应，目前 Taro 已支持 H5 多页开发模式，支持非常迅速。小程序篇由于开发完 H5 版之后，对应的业务逻辑就已经处理完了，接下来只需要处理小程序下的一些特殊逻辑（比如分享、前端测速上报等）即可，差异比较大的就是开发和发布流程。这里讲一下如何在一个原生小程序项目中使用 Taro 进行开发，因为我们的 Taro 项目跟已有的原生小程序项目是独立的两个项目，所以需要将 Taro 项目的小程序代码编译到已有的原生小程序项目目录下，第一步要做的就是调整 Taro 配置 config/index.js ，指定编译输出目录以及禁用 app 文件输出防止覆盖已有文件。const config = {\r\n  // 自定义输出根目录\r\n  outputRoot: process.argv[3] === 'weapp' ? '../.temp' : 'dist',\r\n  // 不输出 app.js 和 app.json 文件\r\n  weapp: {\r\n    appOutput: false\r\n  }\r\n}\r\n复制代码由于京喜以前是主购小程序的一个栏目，后面独立成了独立的小程序，但是核心购物流程还是复用的主购小程序，所以这让情况变得更加复杂。这里还是通过 gulp 来进行繁琐的目录文件处理，比如我们的小程序页面和组件都需要继承主购小程序的 JDPage 和 JDComponent 基类，所以在进行文件复制之前需要进行代码替换，代码如下：// WEAPP\r\nconst basePath = `../.temp`\r\nconst destPaths = [`${basePath}/pages/index/`, `${basePath}/pages/components/`]\r\nconst destFiles = destPaths.map(item => `${item}**/*.js`)\r\n\r\n/*\r\n * 基类替换\r\n */\r\nfunction replaceBaseComponent (files) {\r\n  return (\r\n    gulp\r\n      .src(files || destFiles, { base: basePath })\r\n      .pipe(\r\n        replace(\r\n          /\\b(Page|Component)(\\(require\\(['\"](.*? \"'\"\")\\/npm\\/)(.*)(createComponent.*)/,\r\n          function(match, p1, p2, p3, p4, p5) {\r\n            const type =\r\n              (p5 || '').indexOf('true') != -1 ||\r\n              (p5 || '').indexOf('!0') != -1\r\n                ? 'Page'\r\n                : 'Component'\r\n            if (type == 'Page') p5 = p5.replace('))', '), true)') // 新：page.js基类要多传一个参数\r\n            const reservedParts = p2 + p4 + p5\r\n            // const type = p1\r\n            // const reservedParts = p2\r\n            const rootPath = p3\r\n\r\n            const clsName = type == 'Page' ? 'JDPage' : 'JDComponent'\r\n            const baseFile = type == 'Page' ? 'page.taro.js' : 'component.js'\r\n\r\n            console.log(\r\n              `:full_moon_with_face: Replace with \\`${clsName}\\` successfully: ${this.file.path.replace(\r\n                /.*?wxapp\\//,\r\n                'wxapp/'\r\n              )}`\r\n            )\r\n            return `new (require(\"${rootPath}/bases/${baseFile}\").${clsName})${reservedParts}`\r\n          }\r\n        )\r\n      )\r\n      .pipe(gulp.dest(basePath))\r\n  )\r\n}\r\n\r\n// 基类替换\r\ngulp.task('replace-base-component', () => replaceBaseComponent())\r\n复制代码还有很多类似这样的骚操作，虽然比较麻烦，但是只需要处理一次，后续也很少改动。RN 篇对于 RN 开发，也是第一次将它落地到实际的业务项目中，所以大部分时候都是伴随着各种未知的坑不断前行，所以这里也友情提示一下，对于从未使用过的技术，还是需要一些耐心的，遇到问题勤查勤问。由于京喜 APP 是复用京东技术中台的基础框架和 JDReact 引擎，所以整个的开发和部署都是遵循 JDReact 已有的流程，画了一张大致的流程图如下：JDReact 平台是在 Facebook ReactNative 开源框架基础上，进行了深度二次开发和功能扩展。不仅打通了 Android/iOS/Web 三端平台，而且对京东移动端基础业务能力进行了 SDK 级别的封装，提供了统一、易于开发的 API。业务开发者可以通过 JDReact SDK 平台进行快速京东业务开发，并且不依赖发版就能无缝集成到客户端(android/iOS)或者转换成 Web 页面进行线上部署，真正实现了一次开发，快速部署三端。由于京喜 APP 的 JDReact 模块都是独立的 git 仓库，所以需要调整我们 Taro 项目配置 config/index.js 的编译输出路径如下：rn: {\r\n  outPath: '../jdreact-jsbundle-jdreactpingouindex'\r\n}\r\n复制代码这样，当我们运行 yarn run dev:rn 进行本地开发时，文件自动编译到了 JDReact 项目，接下来我们就可以用模拟器或者真机来进行预览调试了。当我们在进行本地开发调试的时候，最高效的方式还是推荐用 Taro 官方提供的 taro-native-shell 原生 React Native 壳子来启动我们的项目，详细的配置参照该项目的 README 进行配置即可。由于 React Native 官方提供的 Remote Debugger 功能非常弱，推荐使用 React Native Debugger 来进行本地 RN 调试，提供了更为丰富的功能，基本接近 H5 和小程序的调试体验。这样我们就拥有了一个正常的开发调试环境，接下来就可以进行高效的开发了，由于我们前面在 H5 和小程序版本阶段已经完成了绝大部分的业务逻辑开发，所以针对 RN 版本的主要工作集中在 iOS 和安卓不同机型的样式和交互适配上。在样式适配这块，不得不提下 Taro 针对我们常见的场景提供了一些最佳实践，可以作为布局参考：Image\r\nflex\r\nscalePx2dp\r\nTaro RN 最佳实践集锦在实际开发过程中也遇到不少兼容性问题，这里整理出来以供大家参考：文本要用 <Text> 标签包起来，因为 RN 没有 textNode 的概念；使用 Swiper 时在外面包一个 View，否则设置 margin 后会导致安卓下高度异常；Cannot read property 'x' of undefined ，Swiper 底层使用的 react-native-swiper 导致的问题，Disable Remote JS Debug 就不会出现。图片默认尺寸不对，RN 不会自动帮助设置图片尺寸，而是交给开发者自己处理，故意这样设计的；Image 组件上不可以设置 onClick实现基线对齐： vertical-align: baseline ，用 <Text> 把需要基线对齐的组件包住即可。<Text>\r\n  <Text style={{ fontSize: 20 }}>abc</Text>\r\n  <Text style={{ fontSize: 40 }}>123</Text>\r\n</Text>\r\n复制代码尽量避免使用 line-height ，在安卓和 iOS 下表现不一致，而且即使设置为与 fontSize 相同也会导致裁剪；android 调试生产环境的 bundle，摇手机，选 Dev Setting，取消勾选第一项 Dev 即可；iOS 调试生产环境的 bundle， AppDelegate.m 中增加一行语句关闭 dev 即可：[[RCTBundleURLProvider sharedSettings] setEnableDev:false];\r\n  // 找到这行，并在它的上面增加上面这行\r\n  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil];\r\n复制代码<Text> 与 <View> 支持的 style 属性不相同。> [Text Style Props](https://facebook.github.io/react-native/docs/text-style-props \"Text Style Props\") & [View Style Props](https://facebook.github.io/\r\n复制代码react-native/docs/view-style-props)render 方法中不要返回空字符串下面的代码在 android 下会报错（empty_string 内容为空字符串）<View>\r\n  {empty_string && <Text></Text>}\r\n</View>\r\n复制代码因为 empty_string && <Text></Text> 的返回值是空字符串，RN 尝试把字符串添加到 View 的 children 时在安卓环境下会报错：Error: Cannot add a child that doesn't have a YogaNode\r\n复制代码border-radius 导致背景色异常，单独给某个角设置圆角时，没有设置圆角的边会出现一块与背景色颜色相同，但半透明的色块。transform:tanslate()\r\n透明 View 无法点击的问题，给设置了 onClick 的元素添加透明背景色即可：style={{ backgroundColor: \"transparent\" }}\r\n复制代码不可以用 scss 写，只有写在 JSX 上的才有效，Taro 编译时可能把透明背景色忽略了。一像素缝隙问题可能是 RN 布局引擎的问题，或单位转换以及浏览器渲染中的精度损失问题。可以调整页面结构来绕过。 或者简单粗暴一点，设置负 margin 值盖住缝隙。跨平台开发JS 文件1、文件拆分的方式要\"完美\"的编译出三端代码，首先要解决的是公共类库的适配问题，好在兄弟业务团队已经沉淀有完成度较高的三端公共类库，利用 Taro 提供的跨平台开发能力，抹平三端方法名和参数不统一的情况，即可很好的解决公共类库的适配问题，如下所示：.\r\n├── goto.h5.js\r\n├── goto.rn.js\r\n├── goto.weapp.js\r\n├── request.h5.js\r\n├── request.rn.js\r\n├── request.weapp.js\r\n└── ...\r\n复制代码以 request 公共组件为例，三端代码如下：request.h5.jsimport request from '@legos/request'\r\nexport { request }\r\n复制代码request.rn.jsimport request from '@wqvue/jdreact-request'\r\nexport { request }\r\n复制代码request.weapp.js（由于小程序的公共组件没有发布至 npm，这里引用的本地项目源文件）import { request } from '../../../common/request/request.js'\r\nexport { request }\r\n复制代码如遇到需要适配的方法参数不一致或者增加额外处理的情况，可进行再包装确保最终输出的接口一致，如下：goto.rn.jsimport jump from '@wqvue/jdreact-jump'\r\n\r\nfunction goto(url, params = {}, options = {}) {\r\n  jump(url, options.des || 'm', options.source || 'JDPingou', params)\r\n}\r\n\r\nexport default goto\r\n复制代码文件引入的时候我们正常使用就好，Taro 在编译的时候为我们编译对应的平台的文件import goto from './goto.js'\r\n复制代码2、条件编译的方式解决了公共类库适配之后，接下来就可以专注于业务代码开发了，同样业务代码在三端也可能存差异的情况，可以用 Taro 提供的环境变量来达到目的，示例代码如下：if (process.env.TARO_ENV === 'h5') {\r\n  this.speedReport(8) // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'weapp') {\r\n  speed.mark(6).report() // [测速上报] 首屏渲染完成\r\n} else if (process.env.TARO_ENV === 'rn') {\r\n  speed.mark(7).report() // [测速上报] 首屏渲染完成\r\n}\r\n复制代码CSS 文件以上是 js 的代码处理方式，对于 css 文件及代码，同样也有类似的处理。1、文件拆分的方式比如 RN 相对于 H5 和小程序的样式就存在比较大的差异，RN 支持的样式是 CSS 的子集，所以很多看起来很常见的样式是不支持的，可以通过以下方式进行差异化处理：├── index.base.scss\r\n├── index.rn.scss\r\n├── index.scss\r\n复制代码这里以 index.base.scss 作为三端都能兼容的公共样式（名字可以任取，不一定为 xxx.base.scss）， index.rn.scss 则为 RN 端独特的样式， index.scss 则为 H5 和小程序独特的样式，因为 H5 和小程序样式基本上没有什么差异，这里合为一个文件处理。2、条件编译的方式Taro 也支持样式文件内的条件编译，语法如下：/* #ifdef %PLATFORM% */\r\n// 指定平台保留\r\n/* #endif */\r\n\r\n/* #ifndef %PLATFORM% */\r\n// 指定平台剔除\r\n/* #endif */\r\n复制代码%PLATFORM% 的取值请参考 Taro 内置环境变量以下为示例代码：.selector {\r\n  color: #fff;\r\n  /* #ifndef RN */\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n  /* #endif */\r\n}\r\n复制代码编译为 H5 和小程序的样式为：.selector {\r\n  color: #fff;\r\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .1);\r\n}\r\n复制代码RN 的样式为：.selector {\r\n  color: #fff;\r\n}\r\n复制代码两种方式选其一即可，这样就能开开心心的编写业务代码了。有些许遗憾的是产品经理对这次新版首页有着明确的上线优先级：先 H5 版，再微信小程序版，最后是 RN 版，这就为后续 RN 版本跟 H5 和 小程序版本分道扬镳埋下了伏笔，条件允许的话建议优先以 RN 版本为基准进行开发，以免开发完成 H5 和小程序之后发现对结构和样式进行大的调整，因为 RN 对样式确实会弱一些。性能优化图片优化电商性质的网站，会存在大量的素材或商品图片， 往往这些会对页面造成较大的性能影响。得益于京东图床服务，提供强大的图片定制功能，让我们在图片优化方面省去大量工作。以引入商品图片 \"https://img10.360buyimg.com/mobilecms/s355x355_jfs/t1/55430/24/116/143859/5cd27c99E71cc323f/0e8da8810fb49796.jpg!q70.dpg.webp\" 为样本，我们对图片应用做了部分优化：根据容器大小适当裁剪图片尺寸：s355x355_jfs根据网络环境设置图片品质参数：0e8da8810fb49796.jpg!q70根据浏览器环境合理选择图片类型：0e8da8810fb49796.jpg!q70.dpg.webp为 Image 标签设置 lazyload 属性，这样可以在 H5 和小程序下获得懒加载功能。接口聚合直出起初京喜首页的首屏数据涉及的后端接口多达 20 余个，导致整体数据返回时间较长；为了解决此项痛点，我们联合后端团队，独立开发首屏专用的 聚合直出接口 。一方面，将众多接口请求合并成一个，减少接口联动请求带来的性能损耗；另一方面，将复杂的业务逻辑挪到后端处理，前端只负责视图渲染和交互即可，减少前端代码复杂度；通过此项优化，页面性能和体验得到极大改善。缓存优先策略由于京喜业务主要围绕下沉市场，其用户群体的网络环境会更加复杂，要保障页面的性能，减少网络延时是一项重要措施。为了提升用户二次访问的加载性能，我们决定采用 缓存优先策略 。即用户每次访问页面时所请求的主接口数据写入本地缓存，同时用户每次访问都优先加载缓存数据，形成一套规范的数据读取机制。通过优先读取本地缓存数据，可让页面内容在极短时间内完成渲染；另外，本地缓存数据亦可作为页面兜底数据，在用户网络超时或故障时使用，可避免页面空窗的情景出现。高性能瀑布流长列表首页紧接着首屏区域的是一个支持下滑加载的瀑布流长列表，每次滑到底部都会异步拉取 20 条数据，总计会拉取将近 500 条数据，这在 iOS 下交互体验还比较正常。但是在配置较低的安卓机型下，当滑动到 2 到 3 屏之后就开始出现严重卡顿，甚至会闪退。针对这种场景也尝试过用 FlatList 和 SectionList 组件来优化，但是它们都要求规则等高的列表条目，于是不得不自己来实现不规则的瀑布流无限滚动加载。其核心思路是通过判断列表的条目是否在视窗内来决定图片是否渲染，要优化得更彻底些得话，甚至可以移除条目内所有内容只保留容器，以达到减少内容节点以及内存占用，不过在快速进行滑动时比较容易出现一片白框，算是为了性能损失一些体验，整体上来说是可以接受得。由于 RN 下在获取元素坐标偏移等数据相对 H5 和小程序要麻烦得到，具体的实现细节可以查看抽离出来的简单实现 Taro 高性能瀑布流组件（for RN） 。写在最后这篇文章从技术选型、开发实录再到性能优化三个维度对京喜首页改版做了简单总结。整个项目实践下来，证实 Taro 开发框架 已完全具备投入大型商业项目的条件。虽在多端开发适配上耗费了一些时间，但仍比各端独立开发维护工作量要少；在前端资源匮乏的今天，选择成熟的开发工具来控制成本、提升效率，已是各团队的首要工作目标。 同时，京喜作为京东战略级业务，拥有千万级别的流量入口，我们对页面的体验优化和性能改进远不止于此，希望每一次微小的改动能为用户带来愉悦的感受，始终为用户提供优质的产品体验。欢迎关注凹凸实验室博客： aotu.io", "author": "Rolan", "pub_time": "2019-12-4 00:45", "title": "京喜首页（微信购物入口）跨端开发与优化实践 "}
{"content": "某相册类小程序项目总结1.项目简介一款为家庭设计的亲密社交产品，分为云端存储、智能电视、小程序三个平台，小程序端主要功能包括：建立相册，上传图片、视频，单张图片(视频)的预览、分享、下载、评论相册集预览、分享、下载、评论相册内容管理，删除、下载、设置封面、重命名、设置成开机视屏及屏保图片等照片共享，手机、电视多端家庭内容同步和管理邀请、删除家庭成员，添加、删除绑定设备个性化设置家庭昵称、自己昵称、相册名称2. 主要工作和疑难点汇总2.1 主要工作封装api请求，改造wx.requeset方法，封装http请求抽取公共样式文件，在每个page文件夹的.wxss文件中，通过import 引入，\t如：@import \"../../lib/base.wxss\";抽取公共组件，如单个相册组件、弹出卡片组件、个人头像组件、照片卡片组件，通过在各个页面配置usingComponents参数使用。封装全局公共函数业务逻辑接入百度统计, 统计实时数据在我的应用中添加小程序appkey，下载解压后的js文件到utils文件夹中去，同时将百度添加到request合法域名中去。2.2 业务亮点2.3 疑难点汇总如何在小程序中使用less，可以实时转化为 .wxss文件？小程序Page里的函数比app.js先执行的解决办法fixed 元素 auto 不生效原因封装一个有输入框的modal层组件微信小程序去除button默认边框样式小程序如何获取点击元素信息小程序如何在页面间传递数组对象？小程序如何批量上传图片chooseImage、chooseVideo的回调函数中，wx.uploadFile\r\n上传，更新进度\r\nthis.data.updated_length + 1\r\n\r\n当所有照片都上传成功，updated_length == total_length时，\r\n显示完全上传完毕\r\n\r\n视频的进度显示和图片的不一样\r\n图片是每次上传成功一张，updated_length + 1\r\n视频是调用\r\nwx.uploadFile 对象的 onProgressUpdate 函数，看到视频上传进度，每500毫秒更新一次小程序几个组件如何让swiper 跳转到点击的index ？current 参数\r\npreview了, 还能点击图片么,  失败，不使用\r\nhttps://www.cnblogs.com/BlueCc/p/10172742.html动态设置小程序背景图片如何实现分享、点赞功能分享： onShareAppMessage, 点赞：根据本人是否点赞过，是否有点赞权限\r\n\r\nonShareAppMessage: function(res) {\r\n    var obj = {\r\n      from: 'sharephoto',\r\n      mac: app.globalData.mac,\r\n      open_id: app.globalData.open_id,\r\n      member_id: app.globalData.current_member.member_id,\r\n      family_id: app.globalData.family_id,\r\n      album_id: this.data.album_id\r\n    }\r\n    obj = JSON.stringify(obj);\r\n    var name = app.globalData.current_member.nick_name;\r\n    var shareObj = {\r\n　　　　title: `${name}跟你分享了一本有趣的相册集‘${this.data.album_title}’`,        // 默认是小程序的名称(可以写slogan等)\r\n       path:`pages/login/login?message=${obj}`,\r\n　　　　imageUrl: this.data.album_cover,     //自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径，支持PNG及JPG，不传入 imageUrl 则使用默认截图。显示图片长宽比是 5:4\r\n　　　　success: function(res){\r\n　　　　},\r\n　　　　fail: function(){\r\n　　　　}\r\n　　};\r\n　　return shareObj;\r\n  },\r\n        \r\n\r\n\r\n\r\n//节流,300ms才能点一次\r\nif (this.timer) {\r\n  clearTimeout(this.timer)\r\n}\r\nthis.timer = setTimeout(() => {\r\n  console.log('点击点赞', this.data.like_id);\r\n  server.like(family_id, this.data.album_id, mac, member_id, open_id, app.globalData.open_id, form_id,  this.data.like_id).then((res)=>{\r\n    this.getPhotoBlock();\r\n  })\r\n}, 300)如何实现全选、单选功能对某一天日期的照片，如果没张都选了，传递今天整个相册\r\n每次单选照片都会重新判断是否全选小程序时间过滤器 formatTime util的使用wxs中new Date()等js方法不可用,  所以不能用过滤器，还是用方法为什么多个 formId 会重复，因为不支持同时获取多个 formId, 每次只能获取一个如何实现预览照片，点击后跳转到单张照片？wx.previewImage，这里注意 swiper中，currentIndex 左右滑动是否一致，change函数的处理。如何支持同时预览图片和视频？直接使用 wx.previewImage缺点：不能支持视频，不支持对单张照片做其他操作，智能预览，所以先跳转到 swiper页面\r\n点击照片，预览单张照片。点击视频，跳转到vediofull页面。视频播放是否全屏videofullchange，监听全屏事件，小程序视频根据尺寸判断全屏\r\n在 chooseVideo 的时候， 获取视频的高宽解决，如果有其他照片上传失败怎么办？每次调用 showProgress如何判断小程序来源？分享？邀请？this.data.message.from几个值判断，一共有9种情况\r\n\r\n邀请、分享、在家庭中，不在家庭中，是不是管理员，是否来源扫一扫\r\n\r\n单张相片\r\n相册\r\n受到邀请，不在家庭\r\n受到邀请，在家庭中\r\n扫一扫，不在家庭中\r\n扫一扫，在家庭中，是管理员\r\n扫一扫，在家庭中，不是管理员\r\n不是成员，不是扫一扫\r\n已经在家庭中\r\n其他showActionSheet 有长度限制吗？有6个，超过怎么办？二层底部弹卡如何见人照片与视频内容过滤接入百度移动统计授权问题问题出现在，分享给第三人单张照片的时候，未先授权小程序前，不能查看照片，改变login页面逻辑，去掉入门授权，在点击分享、下载时候再询问授权\r\n首页、家庭页，操作后才授权，点击前会有蒙层安全问题需要操作的页面，onLoad都会 checkInFamily，如果不在任何家庭中，跳转到scan页面哪些情况下展示红包？创建相册、邀请成功成员如何通过扫描二维码获得数据wx.scanCode, 获取返回参数如何判断自己有没有全选评论、点赞、编辑？如果照片、视频来源于分享者，且分享人的id=评论id，用分享人的信息给后端传递参数。无论是获取评论、删除评论、发送评论，被分享人都是使用的分享者信息。一级tab页面需要哪些验证？1，首先检查有没有授权，wx.getUserInfo，授权后下一步操作  \r\n2，检查checkIn，在不在家庭中，有没有操作权限，没有退出  \r\n3，获取成员信息，检查有没有红包，有，领取后下一步操作如何拿到信息扫描？wx.scanCode({\r\n      success: (res)...\r\n      \r\n  通过res值获取获取验证码逻辑me.data.timerFun = setInterval(function () {\r\n    if (me.data.timer > 0) {\r\n    me.setData({timer:me.data.timer-1})\r\n    }else {\r\n    me.setData({timer:'重新发送'})\r\n      clearInterval(me.data.timerFun);\r\n    }\r\n    }, 1000);4. 业务逻辑梳理4.1 项目哪几个page组成？有几个组件？| 16个page  | 5个组件 |\r\n|  ----  | ----  |\r\n| login  | 获取token、管理跳转 |\r\n| le_login  | 同步账号 |\r\n| about | 账号绑定、消息、关于、意见反馈 |\r\n|  photo-edit | 照片编辑页 |\r\n| select-device | 选择屏保页面 |\r\n| h5 | 红包页面 |\r\n| comment | 评论列表页面 |\r\n| swiperphotos | 视频、照片滑动页面 |\r\n| vediofull | 全屏播放视频页面 |\r\n| photomanage | 照片管理页面，全选、反选、下载 |\r\n| photos | 相册所有照片页面 |\r\n| one-photo | 单张照片分享页面 |\r\n| homepage | 首页，我的相册页面 |\r\n| familypage | 家庭首页 |\r\n| del-member | 删除成员、设备页面 |\r\n| my-modal | 弹卡组件|\r\n| member-icon | 头像组件|\r\n| photo-album | 相册组件|\r\n| photo-detail | 相册详情组件|\r\n| red-packet | 红包组件|4.2 挑几个页面看看family 页面？1.1 邀请成员主要通过 onShareAppMessage 函数，将邀请人的信息添加在 path的参数中，在login页面中获得1.2 添加设备调整到 homescan页面1.3 退出家庭//如果只剩本人自己, 解散家庭，否则按照退出家庭算photomanage 页面？（点击，下载、设置壁纸，设置屏保后跳转的页面）全选，反选逻辑\r\n\r\n\r\n\r\n设置封面逻辑，如何做到 所有天，只有一个封面？每一天的照片、视频，是一个组件\r\n\r\nselect_photos  所有选中的照片\r\n\r\n\r\n选照片、下载、删除逻辑：\r\n传值过来的是 按日期分布的数组，按照日期对应，修改当天的照片数组。\r\n遍历所有天的照片，计算选中张数，编号。\r\n\r\n设置封面逻辑：\r\n所有天照片，只有有一天选中了，其他所有置灰。photos 页面？ 点击相册进入的页面功能：上传照片、视频，点赞、评论vediofull 页面首先需要创建视频播放上下文对象   \r\nwx.createVideoContext('myVideo');\r\n\r\n退出：\r\n视频对象 pause，退出全屏， 对象置为null\r\n\r\n监听是否需要横屏：\r\n如果视频宽度大于高度，横屏swiperphotos 页面如何支持，同时预览照片和视频？  \r\n不使用原生自带的 wx.previewImage\r\n视频，跳转到 vediofull 页面\r\n\r\n定位到当前照片是，所有 swiper数组的第几章照片  \r\n初始状态，当前滑动照片数，预览照片上面的显示数字，current_index，和 swiper组件绑定的，current值差1，change函数滑动照片，改变current_index值5. 几个组件简介member-icon:支持头像组件两种形态：文字在头像下方、文字在头像右方my-modal:支持弹出会话层有input文本框，支持编辑和新建功能\r\n    \r\n    新建相册名称为空，编辑相册名称为相册名称，怎么做到的？\r\n    新建，文本框内容为update_value，编辑为从父类传过来的数据，textvalue\r\n    \r\n    如何在操作完编辑后，新建，相册名称为空？\r\n    每次确认后，input框内容置空\r\n    \r\n    实时计算文本框字数？\r\n    bindinput函数photo-album: 相册组件每个相册组件，点击跳转到该相册详情页面red-packet: 红包组件//将红包信息参数发送给后端，传递给前端一个web-view 地址链接\r\n    //webview src指向网页的链接。（承载网页的容器，会自动铺满整个小程序页面）\r\n    <web-view src=\"{{link}}\"></web-view>photo-detail: 相册详情组件，支持同一天照片全选、反选，设置屏保、删除、下载等功能如何区分对照片的操作类型？设置封面？下载？删除？根据前一个页面传过来的操作类型判断\r\n    photo-detail只是一天的照片、视频操作，如何将所有日期选中照片传递给后端？\r\n    每次触发某一天的照片，是一个数组，向父元素触发事件，\r\n    \r\n    this.data.photo_block.forEach((item, index)=> {\r\n     if(item.days == photo.days) {\r\n       this.data.photo_block[index] = photo;\r\n     }\r\n   })\r\n   \r\n     \r\n     如何统计总数？\r\n     每次重新计算选中照片。遍历。6. 问题汇总解答1. 如何在小程序中使用less，可以实时转化为 .wxss文件？微信小程序只支持原生css写法，但是很浪费时间，使用 wxss-cli 可以实时将编写的 .less 文件自动编译为 .wxss 文件1、npm或者yarn全局安装wxss-clinpm install -g wxss-cli2、运行wxss-cli命令(miniProject为小程序目录)，less文件保存时自动编译wxss ./miniProject参考资料2. 小程序Page里的函数比app.js先执行的解决办法问题描述：当我们初始化一个小程序时，默认文件 app.js 中有onLaunch函数，onLaunch: function () {\r\n    console.log(\"onLaunch\");\r\n    wx.login({\r\n      success: res => {\r\n        console.log(\"login\");\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n      }\r\n    })\r\n}默认目录，\"pages/index/index\", 中index.js 有 onLoad函数onLoad: function () {\r\n    console.log(\"index onLoad\");\r\n}小程序网络请求默认为异步请求，在app.js的onLaunch运行后进行异步请求时，程序不会停止，index.js页已执行onload, onload里面的数据会因为没有获取到app.js里的东西而报错, 我们希望onLaunch执行完后再执行onLoad。他们的执行顺序是，onLaunch > index onLoad > login我们希望的执行顺序是：onLaunch > login > index onLoad解决办法定义回调函数, onload里获取不到东西就一直获取，不执行下一步操作，直到获取到app.js的数据才继续执行。若login返回为空，则给app.js注册一个loginSuccessCallback回调，这个回调方法的执行时机，就是app.js中的异步请求完毕把 app.js 中的 onLaunch 中方法拿到 index.js 文件中，按照自己的逻辑写使用promise方法1：App({\r\n  onLaunch: function () {\r\n    wx.login({\r\n      success: res => {\r\n        this.globalData.checkLogin = true;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.checkLoginReadyCallback){\r\n          this.checkLoginReadyCallback(res);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    checkLogin: false\r\n  }\r\n  \r\n  ...\r\n})\r\n \r\n\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n \r\nPage({\r\n  data: {\r\n    test: false\r\n  },\r\n  onLoad: function () {\r\n    let that = this;\r\n    //判断onLaunch是否执行完毕\r\n    if (app.globalData.checkLogin){\r\n      that.setData({\r\n        test:true\r\n      })\r\n    }else{\r\n      app.checkLoginReadyCallback = res => {\r\n            //登陆成功后自己希望执行的，和上面一样\r\n        that.setData({\r\n          test:true\r\n        })\r\n      };\r\n    }\r\n  }\r\n})方法2：把 app.js 中的 onLaunch 中登陆后才执行的方法拿到 index.js 文件中，这是最简单的方法//index.js\r\n\r\nonLoad: function () { \r\n    wx.login({\r\n      success: res => {\r\n        resolve(res); \r\n      }\r\n    })\r\n}方法3：// app.js中定义一个新的方法\r\nApp({\r\n  onLaunch: function () {\r\n      ...\r\n  },\r\n  getAuthKey: function (argument) {\r\n    var that = this;\r\n    return new Promise(function(resolve, reject){\r\n        wx.login({\r\n          success: res => {\r\n            resolve(res); \r\n          }\r\n        })\r\n    })\r\n  }\r\n  ...\r\n  \r\n})\r\n\r\n//index.js\r\nonLoad: function () {\r\n    ...\r\n        \r\n    app.getAuthKey().then(function(res){\r\n      console.log('res')\r\n    })\r\n }参考资料：\t参考1 参考2 参考33. fixed 元素 auto 必须要同时设置 top、leftposition: fixed;\r\ntop: 132rpx;\r\nleft: 30rpx;\r\nwidth: 690rpx;\r\nmargin: 0 auto;4.封装一个有输入框的modal层组件其实很简单，就是在modal中添加新的 input,<view>\r\n    <modal class=\"modal\" wx:if=\"{{!hiddenModal}}\"\r\n     title=\"{{title}}\" confirm-text=\"确定\" cancel-text=\"取消\" bindconfirm=\"modalconfirm\" bindcancel=\"modalcancel\">\r\n        <view class=\"input-line\">\r\n            <input placeholder='请输入内容' maxlength=\"{{ maxlength }}\" bindinput='input' type=\"text\" type=\"text\"  value=\"{{ textvalue }}\" />\r\n            <text>{{ currentlength}}/{{ maxlength }}</text>\r\n        </view>\r\n    </modal>\r\n</view>\r\n\r\n.modal{\r\n    width: 540rpx;\r\n    max-width: 540rpx;\r\n    border-radius: 28rpx;\r\n    .input-line {\r\n        display: flex;\r\n        border: 2rpx solid rgba(0, 0, 0, 0.05);\r\n        font-size: 28rpx;\r\n        padding: 16rpx;\r\n        height: 40rpx;\r\n        line-height: 40rpx;\r\n    }\r\n    input,  text{\r\n        display: inline-block;\r\n        vertical-align: top;\r\n    }\r\n    input {\r\n        flex: 1;\r\n    }\r\n    text {\r\n        width: 90rpx;\r\n        color: #FFA004 ;\r\n    }\r\n}5.微信小程序去除button默认边框样式button::after{\r\n    border: none;\r\n}6.小程序如何获取点击元素信息使用驼峰模式，给点击元素绑定 data-\t* ，通过 event.currentTarget.dataset 获取<image src=\"{{ item.mini_pic }}\" class=\"{{ item.show_opacity ? 'show_opacity' : ''}}\" bindtap=\"tap\" data-message=\"{{ item }}\">\r\n</image>\r\n\r\n// 获取的点击节点元素是一个对象\r\n tap: function(event) {\r\n    var message = event.currentTarget.dataset.message;\r\n}7. 小程序如何在页面间传递数组对象？方法1：A页面跳转链接添加参数，B页面onLoad 接受方法2：设置全局变量 globalData，用的少，一般适用于全局共享的一份信息，如用户open_id等// A页面\r\n// 数组、对象都需要stringify\r\nvar listData = JSON.stringify(that.data.listData)\r\nvar taskArray = JSON.stringify(that.data.taskArray)\r\nwx.navigateTo({\r\n    url: '../workRecord/updateBatch?listData=' + listData + '&taskArray=' + taskArray \r\n})\r\n\r\n//B页面\r\nonLoad: function (options) {\r\n    var that = this\r\n    var listData = JSON.parse(options.listData)\r\n    var taskArray = JSON.parse(options.taskArray)\r\n}\r\n\r\n\r\n\r\n//A页面：\r\napp.globalData.open_id = 3;\r\n//B页面：\r\nvar lala = app.globalData.open_id;8. 小程序如何批量上传图片chooseImage、的回调函数中，wx.uploadFile\r\n    上传，更新进度6. 其他封装http请求class HTTP{request({url,data={},method='POST', header={'content-type':'application/json'} }){\r\n            return new Promise((resolve, reject)=>{\r\n                this._request(url,resolve,reject,data, method, header)\r\n            })\r\n        }\r\n        _request(url,resolve, reject, data={}, method='POST', header){\r\n            wx.request({\r\n                url:url,\r\n                method:method,\r\n                data:data,\r\n                header: header,\r\n                success:(res)=>{\r\n                    const code = res.statusCode.toString()\r\n                    if (code.startsWith('2') && res.data.errno == 10000){\r\n                        resolve(res.data)\r\n                    }\r\n                    else{\r\n                        if(res && res.data && res.data.errmsg) {\r\n                            this._show_error(res.data.errmsg)\r\n                        }\r\n                        else {\r\n                            this._show_error(tips[1])\r\n                        }\r\n                        console.log('错111111111')\r\n                        reject(res)\r\n                    }\r\n                },\r\n                fail:(err)=>{\r\n                    reject(err)\r\n                    console.log('错22222222')\r\n                    this._show_error(tips[1])\r\n                }\r\n            })\r\n    \r\n        }\r\n    \r\n        _show_error(tip){\r\n            if(!tip){\r\n                tip = tips[1]\r\n            }\r\n            wx.showToast({\r\n                title: tip,\r\n                icon:'none',\r\n                duration:2000\r\n            })\r\n        }\r\n    }", "author": "Rolan", "pub_time": "2019-12-19 00:02", "title": "某相册类小程序项目总结 "}
{"content": "最近在做自己的小程序《看啥好呢》，这个小程序是使用云开发的方式开发的，功能特别简单，就是获取豆瓣、大麦网的数据展示，虽然功能简单，但还是记录下开发过程和一些技术点，大约会有两篇博文产出，这是第二篇。 GitHub地址背景在《看啥好呢》中有个本地好看 Tab，进去后会获取用户当前所在城市，然后显示该城市的数据，并且显示在导航栏和 Tab上。微信小程序中，我们可以通过调用 wx.getLocation() 获取到设备当前的地理位置信息，这个信息是当前位置的经纬度。如果我们想获取当前位置是处于哪个国家，哪个城市等信息，该如何实现呢？微信小程序中并没有提供这样的API，但是没关系，有 wx.getLocation() 得到的经纬度作为基础就够了，其他的，我们可以使用其他第三方地图服务可以来实现，比如腾讯地图或百度地图的API。所以整个步骤就是：wx.getLocation\r\nreverseGeocoder(options:Object)\r\n在小程序中获取当前的地理位置在小程序中，调用 wx.getLocation ，使用前需要用户授权 scope.userLocation ，代码如下checkAuth(callback) {\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (!res.authSetting\\['scope.userLocation'\\]) {\r\n        wx.authorize({\r\n          scope: 'scope.userLocation',\r\n          success() {\r\n            wx.getLocation({\r\n              type: 'wgs84', \r\n              success(res) {\r\n                callback(res.latitude, res.longitude)\r\n              }\r\n            })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}其中 type 的取值可以为：wgs84 意思返回 gps 坐标gcj02 返回可用于 wx.openLocation 的坐标。运行后会提示如下信息，还需要在 app.json 中配置 permission 字段查询 文档 后得知，得知需要如下配置\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n    }\r\n}desc 用于在弹出的授权提示框中展示，如下允许后即可获取接口返回的信息，此过程会在右上角胶囊按钮上显示箭头图标{\r\n    accuracy: 65\r\n    errMsg: \"getLocation:ok\"\r\n    horizontalAccuracy: 65\r\n    latitude: 30.25961    // 纬度，范围为 -90~90，负数表示南纬\r\n    longitude: 120.13026    // 经度，范围为 -180~180，负数表示西经\r\n    speed: \\-1\r\n    verticalAccuracy: 65\r\n}latitude 和 longitude 即是我们需要的两个字段腾讯地图接口逆地址解析以腾讯地图为例，我们可以去腾讯地图开放平台注册一个账号，然后在它的管理后台创建一个密钥(key)，以及进行KEY设置，按照 微信小程序JavaScript SDK 入门及使用限制文档在 KEY设置的启用产品中，勾选 WebServiceAPI，选择签名校验方式，因为我是使用云开发的方式，所以没有什么域名也没有授权IP。这部分代码逻辑如下import QQMapWX from '../../scripts/qqmap-wx-jssdk.min.js'\r\nlet qqmapsdk\r\nPage({\r\n    onLoad: function (options) {\r\n      // 实例化API核心类\r\n      qqmapsdk = new QQMapWX({\r\n         key: '开发密钥（key）'    // 必填\r\n      });\r\n      this.checkAuth((latitude, longitude) => {\r\n         // https://lbs.qq.com/qqmap\\_wx\\_jssdk/method-reverseGeocoder.html\r\n         qqmapsdk.reverseGeocoder({\r\n           sig: 'KEY设置中生成的SK字符串',    // 必填\r\n            location: {latitude, longitude},\r\n            success(res) {\r\n                wx.setStorageSync('loca\\_city', res.result.ad\\_info.city)\r\n            },\r\n            fail(err) {\r\n               console.log(err)\r\n               wx.showToast('获取城市失败')\r\n            },\r\n            complete() {\r\n               // 做点什么\r\n            }\r\n         })\r\n      })\r\n    }\r\n}）reverseGeocoder 接口返回的结果，这里面的字段比较多，详细可以看接口文档，里面好几个字段可以取到城市，其中 ad_info 是行政区划信息，我就取这里面的 city 了。全文完。关注公众号，第一时间接收最新文章。如果对你有一点点帮助，可以点喜欢点赞点收藏，还可以小额打赏作者，以鼓励作者写出更多更好的文章。", "author": "Rolan", "pub_time": "2019-12-19 00:18", "title": "实战：在小程序中获取用户所在城市信息 "}
{"content": "微信小程序中，有时候文本需要实现这样的功能 1、文本超过n行显示省略号 2、省略时，显示 展开/收起 按钮 3、文本不超过n行时，不显示省略号和展开/收起按钮 实现思路文本过长显示省略号、展开和收起功能，通过css样式即可实现 判断是否显示展开/收起按钮： 通过嵌套元素，可以实现text既显示省略号，其高度又是全显示时的高度 通过SelectorQuery选择器，获取text及其父元素的高度，判断text高度是否超过其父元素高度，决定是否显示展开/收起按钮即可代码wxss.frame {  width: 100%;  max-height: 206rpx;  text-align: left;  display: -webkit-box;  overflow: hidden;  text-overflow: ellipsis;  word-wrap: break-word;  white-space: normal !important;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;}.nofold {  display: block;  text-overflow: unset;  -webkit-line-clamp: unset;  max-height: unset;}frame样式设置最大高度，超过3行后出现省略号。overflow为hidden，使得text的超出父元素部分隐藏掉。nofold样式则将最大高度、出现省略号的行数去除，以展示全文。wxml<view id=\"frame\" class='frame {{fold == false ? \"nofold\":\"\"}}'>    <text id=\"content\">{{detail}}</text></view>wxml中，在view元素中嵌套text元素。样式写在view中，text不加任何样式（重要）。分别写上id，方便js代码获取其尺寸信息。 javascriptvar query = this.createSelectorQuery();query.select('#content').boundingClientRect();query.select('#frame').boundingClientRect();query.exec(function(res) {  if (res[0] && res[0].height) {    if (res[0].height > res[1].height) {      self.setData({        fold: true,      });    } else {      self.setData({        fold: null,      });    }  }})js代码中，通过选择器获取两者的高度，如果text高度高于view，则说明有省略文本，显示展开/收起按钮。 js的选择器如果是写在onshow/onload方法中，最好加上延迟，以防止出现判断时元素尚未渲染出来的情况。", "author": "Rolan", "pub_time": "2019-12-19 00:44", "title": "微信小程序文本展开/收起功能 "}
{"content": "背景需求：最近接了一个需求，需要做一个类似电影院的选座功能，不同的是需要自己选择日期，预定时间段，然后根据日期+时间段查询座位信息，结合图片说下需求。a、日期组件可选2天内（当天+第二天）。进入页面默认展示当天日期，预定开始时间为当前时间，预定结束时间为开始时间之后30分钟。b、日期确定后才能选择预定开始时间，开始时间以及结束时间我这边是固定的时间点（08:30-22:30）。开始时间分钟段以5分钟为倍数设置往后推算展示，其余时段不显示。如果当前时间为22:00，则不展示当天时间，自动切换到第二天。c、选择预定结束时间。结束时间已开始时间为标记，半小时为倍数生成规则，其余时段不显示。两个时间段确定以后算出预定时长（小时为单位），并调后端接口查询座位信息。", "author": "Rolan", "pub_time": "2019-12-23 00:33", "title": "基于微信小程序picker组件开发的时间自定义功能 "}
{"content": "在用户使用HyperMotion产品过程中，用户可以通过扫描产品中二维码方式，自助进行Licnese申请。用户提交申请后，请求将发送到钉钉流程中。完成审批后，后台服务将自动根据用户的特征码、申请的数量、可使用的时间将生成好的正式Licnese发送到客户的邮箱中。在原有设计中，使用了Python Flask提供WEB界面，后台使用Celery异步的将用户请求发送至钉钉中，之后采用轮询方式监控审批工单状态，当工单完成审批后，将生成好的License发送至客户提供的邮箱中。实现的效果：这种方式虽然可以满足需求，但是在使用过程中也发现有如下痛点：1、由于对于可用性要求比较高，所以将整套应用以容器化方式部署在云主机上，程序高可用性依赖于底层的平台，基于成本考虑并没有在多可用区进行部署。2、当业务变化时，需要专人将容器从本地容器库上传后进行更新，更新速度慢，敏捷性低。3、需要专人对操作系统层进行维护，并且由于该云主机还运行了其他程序，所以管控上也存在安全风险。基于以上出现的问题，决定对原有二维码程序进行重构，并重新部署在阿里云函数计算服务上。1、第一阶段的改造主要是将二维码扫描程序移植到函数计算服务中。2、第二阶段的改造主要是将发送二维码程序改造为函数计算服务，使用钉钉流程接口中的Callback方法调用该接口，在审批结束后触发发送License流程。2、函数计算服务——无服务，零运维最早接触Serverless的雏形是在2011年开发Cloud Foundry项目时，当时留下一个非常深的印象就是把写好的应用直接上传就完成了部署、扩展等。但是当时Cloud Foundry有一个非常大的局限性，受限于几种开发语言和框架。记得当时的Cloud Foundry只支持Node.js、Python、Java、PHP、Ruby on Rails等，脱离了这个范围则就无法支持，所以当时我其实对这种形态的应用场景存在很大的疑问。这种困惑直到2013年Docker的出现而逐步解开，Docker的出现让开发语言、框架不再是问题，巧妙的解决了Cloud Foundry上述局限性。但是Docker毕竟只是一种工具形态，还不能称得上是平台，紧接着k8s的出现弥补了这一空白，使得Docker从游击队变成了正规军。在这个发展过程中我们不难看出，软件领域发展出现了重大变革，从服务器为王逐渐演进到应用为王的阶段。如果说虚拟化改变了整个物理机的格局，那么无服务化的出现则改变了整个软件开发行业。由于网上各种文档太多了，这里就不对Serverless基本概念进行介绍了，借用一张图说明下。另外还有一点，我们从这里面看到IT行业里的某些岗位，注定要消失的，比如传统运维。3、应用架构整个架构上，分为两个函数计算服务完成：二维码前端：主要用于显示页面，并承担HTTP请求转发代理的角色，将请求转发至二维码后端，发给钉钉，采用HTTP触发器，允许公网访问。二维码后端：用于将用户请求发送给钉钉，该部分服务仍然采用HTTP触发器，不同于前端，该服务是不允许公网直接访问的，但是需要配置NAT网关，通过网关访问钉钉，实现固定IP访问钉钉的效果。从逻辑上讲，整个应用并不复杂，但是在实际使用时遇到最大的问题来自钉钉白名单。由于函数服务对外连接的IP并不固定，所以无法在钉钉中添加，那么就要求函数服务对外连接的IP地址一定要固定。社区中提供的方法主要分为：ECI（运行Nginx充当Proxy），优势是便宜，劣势是高可用性需要自己维护NAT网关，优势是高可用性，劣势是比ECI贵4、构建过程由于篇幅原因，这里只介绍关键步骤。4.1 构建模板为了后续管理和扩展方便，选用了阿里云函数计算中使用flask-web模板进行构建，同时可以将前端静态文件模板存放于项目下（出于统一管理的需要，也可以存放于阿里云的OSS中，作为静态网站发布）。前端我们使用flask-web作为模板创建函数，后端我们直接采用最简单的HTTP函数。函数入口配置，及触发器配置：服务配置，包含公网访问权限，专有网络配置，日志配置，权限配置。前端服务需要公网访问权限，不需要专有网络配置，需要的权限为：AliyunLogFullAccess。后端服务不需要公网访问权限，但是需要配置好的NAT映射的专有网络，由于函数服务在北京2区中在cn-beijing-c和cn-beijing-f，所以在新建交换机时需要使用这两个区。还需要选择安全组，由于出方向并没有明确禁止，所以不需要特别的安全组规则设定。需要的权限为：AliyunLogFullAccess/AliyunECSNetworkInterfaceManagementAccess。配置好后，通过导出功能，分别下载前端和后端代码和配置，在本地进行开发调试。4.2 前端开发我们的前端采用Vue.js进行开发，在main.py同级新建templates目录。Vue编译好的静态文件可以放入该目录中，后续Flask会加载该文件作为入口文件。├── templates\r\n│   ├── index.html\r\n│   ├── static\r\n├── main.py\r\n# main.py sample\r\nfrom flask import render_template\r\n\r\nLICENSE_URL = \"https://[x](https://.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license).cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license\"\r\n\r\n@app.route('/qr_code', methods=['GET'])\r\ndef index():\r\n      return render_template('index.html')\r\n\r\n      @app.route('/qr_code/license', methods=['POST'])\r\n      def create():\r\n            payload = request.json\r\n                resp = requests.post(LICENSE_URL,\r\n                                                 json=payload,\r\n                                                                              headers=DEFAULT_HEADERS)\r\n                return make_response(resp.text, resp.status_code)\r\n4.3 后端开发后端的开发较为简单，实现一个函数支持POST请求，将转发的结果发送至钉钉即可。4.4 本地调试阿里云在本地开发时提供了fun应用部署和开发工具，详细使用方法见： https://help.aliyun.com/document_detail/64204.html 。安装funnpm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) --global\r\nnpm config set disturl [https://npm.taobao.org/dist](https://npm.taobao.org/dist) --global\r\n\r\nnpm install @alicloud/fun -g\r\n配置funfun config\r\n\r\n(venv) [root@ray-dev test_func]# fun config\r\n? Aliyun Account ID xxxxxxxx\r\n? Aliyun Access Key ID ***********r5Qd\r\n? Aliyun Access Key Secret ***********kCCi\r\n? Default region name cn-beijing\r\n? The timeout in seconds for each SDK client invoking 10\r\n? The maximum number of retries for each SDK client 3\r\n? Allow to anonymously report usage statistics to improve the tool over time? Yes\r\nHttp Trigger本地运行fun local start\r\n部署fun deploy\r\n4.5 配置域名解析部署完成后有一点需要特别注意，必须要绑定域名，并且设定必要的路由。如果在没有绑定域名的情况下，服务端会为 response header中强制添加 content-disposition: attachment字段，此字段会使得返回结果在浏览器中以附件的方式打开。（ https://www.alibabacloud.com/help/zh/doc-detail/56103.htm ）", "author": "Rolan", "pub_time": "2019-12-23 00:43", "title": "使用阿里云函数计算构建小程序 "}
{"content": "问题复现：在项目根目录执行npm init -y # 初始化npm最近在学习7yue老师的koa课，使用到npm包，出现这个问题，目录结构如下工具 -> 构建 npm -> '没有找到可以构建的 NPM 包'查看文档查阅npm 支持| 微信开放文档)有如下说明此处并没有强制要求 node_modules 必须在小程序根目录下（即 project.config.js 中的 miniprogramRoot 字段），也可以存在于小程序根目录下的各个子目录中。但是不允许 node_modules 在小程序根目录外。所以： npm包应放在小程序根目录下 ，而我搞混了小程序目录和项目根目录小程序根目录(为 /project.config.json 中 miniprogramRoot字段指定)项目根目录(为 / )是两个不同位置原来是我的node-models放错了地方，正确位置应该是**miniprogram**文件夹下问题解决cd miniprogramnpm init -ynpm install lin-ui --production工具 -> 构建 npm目录如下，出现了miniprogram_npm", "author": "Rolan", "pub_time": "2019-12-23 00:52", "title": "小程序 找不到可构建的npm包-解决方法 "}
{"content": "第一版做了知乎视频保存视频到本地相册的功能。进一步我们可以做一个增强功能，支持视频查看。用户在登录状态下载过的知乎视频，可以在我的浏览或者查看历史记录在线查看视频这个功能的核心其实是用户身份标识的获取，因为我们只要拿到了用户标识，相应用户下载过的视频就可以和用户标识绑定，存储到数据库中。当用户下次再进入app，只要通过用户标识就可以去数据库中拿用户之前下载过的视频就可以了。表结构如下：CREATE TABLE `wx_user_zhihu_answer` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '软删除标识',\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\r\n  `openId_md5` varchar(128) NOT NULL DEFAULT '' COMMENT 'openId md5加密',\r\n  `answer_url` varchar(128) NOT NULL DEFAULT '' COMMENT '知乎回答url',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_is_delete` (`is_delete`),\r\n  KEY `idx_openId_md5` (`openId_md5`),\r\n  KEY `idx_answer_url` (`answer_url`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户及知乎回答信息';获取用户标识我们借鉴微信的例程来设计用户登录逻辑首先按钮上设置open-type=\"getUserInfo\",可以让用户自主选择是否授权小程序。<button class=\"login-btn\" wx:if=\"{{!hasUserInfo}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  点击登录\r\n</button>当用户点击并确认授权，会执行回调的getUserInfo方法getUserInfo: function(e) {\r\n  app.globalData.userInfo = e.detail.userInfo;\r\n  this.setData({\r\n    userInfo: e.detail.userInfo,\r\n    hasUserInfo: true\r\n  });\r\n\r\n  // 登录\r\n  wx.login({\r\n    success: res => {\r\n      const { code } = res;\r\n      app.globalData.loginInfo.jsCode = code;\r\n      this.fetchUserIdInfo();\r\n      // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n    }\r\n  });\r\n  // 获取用户信息\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n        wx.getUserInfo({\r\n          success: res => {\r\n            const { encryptedData, iv } = res;\r\n            // 可以将 res 发送给后台解码出 unionId\r\n            app.globalData.loginInfo.encryptedData = encryptedData;\r\n            app.globalData.loginInfo.iv = iv;\r\n            this.fetchUserIdInfo();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n},\r\nfetchUserIdInfo() {\r\n  const { jsCode, encryptedData, iv } = app.globalData.loginInfo;\r\n  if (!(jsCode && encryptedData && iv)) {\r\n    return;\r\n  }\r\n  wx.request({\r\n    url: userInfoFetchUrl,\r\n    method: \"POST\",\r\n    data: {\r\n      jsCode,\r\n      encryptedData,\r\n      iv\r\n    },\r\n    header: {\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    success: res => {\r\n      res = res.data;\r\n      if (res.code === 1) {\r\n        app.globalData.userIdInfo = res.data;\r\n      }\r\n    }\r\n  });\r\n},getUserInfo可以获取用户的信息，调用wx.login能够拿到code,调用wx.getUserInfo能够拿到encryptedData和iv。拿到code、encryptedData、iv我们就可以调用微信接口以及解码逻辑拿到用户的openId和unionId,我们这部分都放在了后端接口(userInfoFetchUrl)处理，这里我们使用openId标识用户身份，该接口返回的是openId用m5加密后的id。由于所以身份标识相关的操作都在服务器进行且返回的是md5加密后的值，所以极大提高了用户信息的安全性。后端解析用户标识的逻辑如下exports.infoFetch = async params => {\r\n  const { jsCode, encryptedData, iv } = params;\r\n  const sessionRes = await axios.get(\r\n    `${jscode2sessionUrl}?appid=${appId}&secret=${appSecret}&js_code=${jsCode}&grant_type=authorization_code`\r\n  );\r\n  const sessionResData = sessionRes.data;\r\n  const sessionKey = sessionResData.session_key;\r\n  const openId = sessionResData.openid;\r\n  const pc = new WXBizDataCrypt(appId, sessionKey);\r\n  const userInfo = pc.decryptData(encryptedData, iv);\r\n  const unionId = userInfo.unionId;\r\n  if (unionId && openId) {\r\n    return {\r\n      openIdMD5: md5(openId),\r\n      unionIdMD5: md5(unionId)\r\n    };\r\n  } else if (openId) {\r\n    return {\r\n      openIdMD5: md5(openId)\r\n    };\r\n  }\r\n  return {};\r\n};拿到用户标识后工作基本就完成了。我们还需要做一些优化，在app.js的onLaunch回调和登录页onLoad回调中获取用户信息，使得用户再次打开app在有效登录时间内依然可以直接使用用户标识。", "author": "Rolan", "pub_time": "2019-12-24 00:04", "title": "【微信小程序】知乎视频查看 "}
{"content": "小程序原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考 WeUI 的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码： https://gitee.com/piscdong/we...效果如下图，可以自定义宽高，可以做成方角的代码分析这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：<view class=\"switch\">\r\n    <view></view>\r\n</view>父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。.switch {\r\n    ...\r\n    background: #00c000;\r\n    position: relative;\r\n}未选中时::before覆盖整个容器，选中时::before设置 transform: scale(0); ，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。.switch::before {\r\n    display: block;\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 9999rpx;\r\n    background: #fff;\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked::before {\r\n    transform: scale(0);\r\n}来回移动的白点，未选中时通过 left: 0; 定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上 transform: translateX(-100%); 将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。.switch view {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 60rpx;\r\n    height: 60rpx;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.4);\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked view {\r\n    left: 100%;\r\n    transform: translateX(-100%);\r\n}关于“::”最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。", "author": "Rolan", "pub_time": "2019-12-24 00:51", "title": "【微信小程序】写一个能自定义尺寸、样式的switch "}
{"content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给小程序，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：任何绑定id的自定义组件都能够方便抓取实例对象(任何嵌套层级均可调用)通过数据配置思路实现不难，我们可以将所有自定义组件在create生命周期方法时将\tthis 挂载到一个全局变量中，\tdetached 生命周期时销毁该实例(不然爆内存)实现准备一个全局变量app._elements = {}\r\n复制代码挂载/销毁方法一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上app.mount = function(id, context){\r\n    app._elements[id] = context\r\n}\r\n\r\napp.unmount = function(id){\r\n    app._elements[id] = null\r\n}\r\n复制代码getElementsById定义全局\tgetElementsById 在Page中能够方便调用app.getElementsById = function(id){\r\n    let res = app._elements[id]\r\n    if (!res) {  // 兼容selectComponent\r\n        return wx.selectComponent('#'+id) || wx.selectComponent('.'+id)\r\n    }\r\n    return res\r\n}\r\n复制代码自定义组件ui-component组件const app = getApp()\r\nComponent({\r\n  options: {\r\n    multipleSlots: true, // 在组件定义时的选项中启用多slot支持\r\n    addGlobalClass: true\r\n  },\r\n  properties: {\r\n    dataSource: {\r\n      type: Object,\r\n    },\r\n  },\r\n  data: {},\r\n  behaviors: [],\r\n  lifetimes: {\r\n    created: function() {\r\n    },\r\n    attached: function() {\r\n        this.id = this.data.dataSource.$$id  // 专用$$id来指定唯一名称\r\n    },\r\n    ready: function() {\r\n        app.mount(this.id, this)\r\n    },\r\n    detached: function(){\r\n        app.unmount(this.id)\r\n    }\r\n  },\r\n  methods: {\r\n      active(clsName){\r\n          /* do something */\r\n      }\r\n  })\r\n复制代码应用下面开始在Page中使用\tgetElementsById 来抓取自定义组件实例wxml<ui-component dataSource=\"{{config}}\" />\r\n复制代码jsPage({\r\n    data: {\r\n        config:  {\r\n            $$id: 'component-id',\r\n            title: 'some text'\r\n        }\r\n    },\r\n    \r\n    onReady(){\r\n        // 我们应该在onReady中来调用，onLoad时，页面组件结构并没有渲染完成  \r\n        const $ele = app.getElementsById('component-id')\r\n        $ele.active('.active') \r\n    }\r\n})\r\n复制代码至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈", "author": "Rolan", "pub_time": "2019-12-24 00:52", "title": "小程序的getElementsById，就像一把梭 "}
{"content": "以下内容来自于去年的一次案例，随着微信小程序的不断改版，部分条件可能已不再适用，请谨慎参考。内容比较短，主要都在代码片段里。案例某个项目中需要用到如下图这样的一个圆环行的进度条。一开始的想法是使用canvas来实现，但是canvas是原生组件，层级最高（当时的情况），实际使用时不方便使用。所以决定尝试用纯CSS来实现这一效果。实现原理先上代码：https://developers.weixin.qq....这里主要用到的是CSS中的clip属性，将一个正方形裁剪后只显示右侧一半，但是仍然以正方形中心为圆心来旋转，来实现需要的角度。clip: rect(0rpx, 46rpx, 92rpx, 0rpx);这样最上面那个进度条就可以由以下三部分叠加，在最上面再叠加一个小一号的白色圆形，最外层加上圆角后就可以实现。（下图中红线示例了最外层的圆角以及最上层叠加的白色圆形位置）叠加效果用到蓝色圆环小于180度的情况下，需要把背景色和前景色对调。", "author": "Rolan", "pub_time": "2019-12-27 00:07", "title": "纯CSS实现圆环型进度条 "}
{"content": "先看效果主要结构我用的mpvue，如用原生标签直接转换成原生即可<div id=\"labelBox\">\r\n    <div class=\"label userLabel\" v-for=\"(label,inx) in labelList\" :key=\"inx\">{{label}}</div>\r\n    <div class=\"more\" v-show=\"showLabel===1\" id=\"moreLabel\" @click=\"openMore\">\r\n        <div>全部{{allLabel.length}}个</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_down.png\" />\r\n    </div>\r\n    <div class=\"more\" v-show=\"showLabel===2\" @click=\"closeMore\">\r\n        <div>收起</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_up.png\" />\r\n    </div>\r\n</div>export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    ...\r\n}思路利用小程序api NodesRef.boundingClientRect 获取节点的位置与大小信息，主要用到 width,left,right循环所有标签(.userLabel)，看是否有多行，通过所有节点的 left 去判断，如果 left 相同的有多个，就证明有多行获取标签父级(#labelBox)的宽度 width获取到按钮(#moreLabel)的宽度过滤第一行节点的 right，如果与按钮的width相加小于等于父级盒子的width就保留 具体的代码\r\n wxp为微信接口Promise化，会在之后列出用到的\r\n\r\n export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    methods: {\r\n        async loadPageData(){\r\n            // 请求后台数据\r\n            const res = ...\r\n\r\n            // 设置\r\n            this.allLabel = res.labes;          // 记录所有的标签\r\n            this.labelList = this.allLabel;     // 先插入所有表情\r\n            // 设置状态\r\n            if(this.allLabel.length>0){\r\n                await wxp.timeout(300); // 插入视图之后不会马上获取到节点信息，延迟获取\r\n                this.setLabelStauts();\r\n            }\r\n            \r\n        },\r\n\r\n        // 设置标签状态\r\n        async setLabelStauts(){\r\n            const boxDom = await wxp.getElementById('#labelBox');\r\n            const labelDoms = await wxp.getElementsByClassName('.userLabel');\r\n            const btnDom = await wxp.getElementById('#moreLabel');\r\n            const left = labelDoms[0].left;\r\n\r\n            // 分行转为二维数组\r\n            let lineArr = [];       \r\n            let lineIndex = -1;\r\n            labelDoms.forEach(v => {\r\n                if(v.left==left){\r\n                    lineIndex++;\r\n                    lineArr[lineIndex] = [];\r\n                }\r\n                lineArr[lineIndex].push(v);\r\n            })\r\n\r\n            // 超过一行\r\n            if(lineArr.length>1){\r\n                // 默认显示加载更多按钮\r\n                this.showLabel = 1;\r\n                const firstTr = lineArr[0].filter(v => (v.right+btnDom.width+(left/15*15)) <= boxDom.width);\r\n                this.firstLabel = this.allLabel.slice(0,firstTr.length);\r\n                this.labelList = this.firstLabel;\r\n            }else{\r\n                this.showLabel = 0;\r\n            }\r\n        },\r\n\r\n        // 展开\r\n        openMore(){\r\n            this.showLabel = 2;\r\n            this.labelList = this.allLabel;\r\n        },\r\n        // 收起\r\n        closeMore(){\r\n            this.showLabel = 1;\r\n            this.labelList = this.firstLabel;\r\n        }\r\n    }\r\n}wxp.js相关代码/**\r\n * 延时\r\n * @param {*} delay \r\n */\r\nexport const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n/**\r\n * 根据ID获取dom的盒模型信息\r\n * @param {*} id \r\n */\r\nexport const getElementById = (id='') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof id).toLowerCase() !=='string'){\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (id.indexOf('#') < 0) {\r\n            const err = {\r\n                errMsg: '请输入ID，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        }else{\r\n            var query = wx.createSelectorQuery()\r\n            query.select(id).boundingClientRect();\r\n            query.selectViewport().scrollOffset();\r\n            query.exec(rect => {\r\n                if (rect[0]){\r\n                    let info = rect[0];\r\n                    info.position = {\r\n                        left: rect[1].scrollLeft + info.left,\r\n                        top: rect[1].scrollTop + info.top\r\n                    };\r\n                    resolve(info);\r\n                }else{\r\n                    const err = {\r\n                        errMsg: '没有获取到信息'\r\n                    }\r\n                    reject(error(err.errMsg,err));\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * 根据类名获取dom信息\r\n * @param {*} className \r\n */\r\nexport const getElementsByClassName = (className = '') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof className).toLowerCase() !== 'string') {\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (className.indexOf('.') < 0) {\r\n            const err = {\r\n                errMsg: '请输入类名，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else {\r\n            wx.createSelectorQuery().selectAll(className).boundingClientRect(rects => {\r\n                resolve(rects);\r\n            }).exec();\r\n        }\r\n    })\r\n}作者：不二很纯洁链接：https://www.jianshu.com/p/87f3c14038a6", "author": "Rolan", "pub_time": "2019-12-27 00:41", "title": "小程序标签展开收起功能实现 "}
{"content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态边界值(最大值，最小值)，初始值，步进值(一次增减数量)需要可控边界状态，即超出后显示为什么状态可供外部设置边界状态的api方法内部加减方法可供外部调用的加减方法(一些场景中，外部有一个总量约束，比如sku场景)加减回调方法，比如当数量超出时提示用户相关信息多实例模式，实例之间即隔离又能交互大致需求如上，demo及实现部分如下GITHUB源码小程序代码片段wxml<view class=\"container\">\r\n  <ui-item item=\"{{steperConfig}}\" />\r\n</view>\r\n复制代码Page因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了const Pager = require('../components/aotoo/core/index')\r\nlet lib = Pager.lib\r\n\r\nfunction mkSteper(id=lib.suid('step_'), min, max, step=1) {\r\n  return {\r\n    $$id: id,\r\n    itemClass: 'steper-class',\r\n    title: [\r\n      {title: '-', aim: 'reduce', itemClass: 'steper-reduce'},\r\n      {title: '0', aim: 'custom', itemClass: 'steper-counter'},\r\n      {title: '+', aim: 'plus', itemClass: 'steper-plus'},\r\n    ],\r\n    methods: {\r\n      __ready(){\r\n        this.count = 0\r\n        this.min = min||0\r\n        this.max = max||10\r\n        this.step = step||1\r\n        this.stat = {\r\n          reduce: true,\r\n          plus: true,\r\n          count: true\r\n        }\r\n      },\r\n      reduce(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[0]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (e === true) {\r\n          this.stat.reduce = true\r\n          inst.removeClass('disable')\r\n        }\r\n\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count -= step\r\n        if (this.count <= this.min) {\r\n          this.count = this.min\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (this.count < this.max && !this.stat.plus) {\r\n          this.stat.plus = true\r\n          let $plus = inst.siblings('steper-plus')\r\n          $plus.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('reduce', {count: this.count}, this)\r\n\r\n      },\r\n      plus(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[2]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (e === true) {\r\n          this.stat.plus = true\r\n          inst.removeClass('disable')\r\n        }\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count += step\r\n        if (this.count >= this.max) {\r\n          this.count = this.max\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (this.count > this.min && !this.stat.reduce) {\r\n          this.stat.reduce = true\r\n          let $reduce = inst.siblings('steper-reduce')\r\n          $reduce.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('plus', {count: this.count}, this)\r\n      },\r\n      changeNum(inst){\r\n        let count = this.count\r\n        if (typeof inst === 'number') {\r\n          count = inst\r\n          inst = undefined\r\n        }\r\n\r\n        if (!inst) {\r\n          inst = this.children[1]\r\n        }\r\n\r\n        let $counter = inst.siblings('steper-counter')\r\n        $counter.update({\r\n          title: count\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    steperConfig: mkSteper('steper'),\r\n  },\r\n  onReady(){\r\n    let $steper = this.getElementsById('steper')\r\n    $steper.hooks.on('plus', function(param) {\r\n      if (this.count === 10) {\r\n        Pager.alert('不能再多了，仓库没货了')\r\n      }\r\n    })\r\n    $steper.hooks.on('reduce', function(param) {\r\n      if (param.count <= 0) {\r\n        Pager.alert('大哥，买点啊')\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码", "author": "Rolan", "pub_time": "2019-12-30 00:29", "title": "xquery小程序简易步进器 "}
{"content": "最近做了一个红包兑换小程序，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp分享图的问题1、 measureText 获取宽度的时候，传入的参数如果是数字，则会返回0。let money = 10;  //这里需要把数字转成字符串\r\nctx.measureText(money).width;\r\n2、绘制图片的时候不要忘了先使用 getImageInfo 转成临时地址，再 drawImage ，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。3、需要绘制微信头像的时候，要在后台配置downloadFile合法域名 https://wx.qlogo.cn 4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：把背景图片尽量再压缩，最终是60多KB。调 canvasToTempFilePath 的时候，设置 fileType 为jpg，quality范围是(0,1]，取个合适的值。 5、小程序里面的保存图片并不是长按保存的，需要点击按钮授权。<button  open-type=\"getUserInfo\"  @getuserinfo=\"onGotUserInfo\"></button>、\r\n...\r\nonGotUserInfo(e){\r\n\tuni.saveImageToPhotosAlbum({\r\n\t\tfilePath: this.tempPath,\r\n\t\tsuccess(res) {\r\n\t\t\tuni.showToast({\r\n\t\t\t  title: '保存成功',\r\n\t\t\t  icon: 'success',\r\n\t\t\t  duration: 1500\r\n\t\t\t})\r\n\t\t},\r\n\t\tfail(err){\r\n\t\r\n\t\t}\r\n\t})\r\n}\r\n...\r\n如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在 saveImageToPhotosAlbum 的fail回调函数里面操作，再次获取保存到相册权限。if (err.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || err.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\" || err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n  uni.showModal({\r\n\ttitle: '提示',\r\n\tcontent: '需要您授权保存相册',\r\n\tshowCancel: false,\r\n\tsuccess:res=>{\r\n\t  uni.openSetting({\r\n\t\tsuccess(settingdata) {\r\n\t\t  if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限成功,再次点击保存图片按钮即可保存',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  } else {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限失败，将无法保存到相册哦~',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  }\r\n\t\t},\r\n\t\tfail(failData) {\r\n\t\t  console.log(\"failData\",failData)\r\n\t\t},\r\n\t\tcomplete(finishData) {\r\n\t\t  console.log(\"finishData\", finishData)\r\n\t\t}\r\n\t  })\r\n\t}\r\n  })\r\n}\r\n点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。原生微信小程序和uniapp框架的一些对比针对此次项目，这里挑两点来写。全局变量的管理1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jsApp({\r\n    globalData: {\r\n        session:\"\"\r\n    }\r\n})\r\npages/index/index.js...\r\nconst app = getApp()//获取应用实例\r\napp.globalData.session = \"xxxx\" //设置\r\napp.globalData.session  //读取\r\n...\r\n2、uniapp用的是vue的那套，所以可以用vuex来管理状态import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nVue.use(Vuex);\r\nconst store = new Vuex.Store({\r\n\t state : {\r\n\t\tsession:\"\"\r\n\t },\r\n\t mutations : {\r\n\t\tgetSession(state, res){\r\n\t\t\tstate.session = res;\r\n\t\t},\r\n\t }\r\n});\r\nexport default store\r\n设置this.$store.commit('getSession',res.session) //接口返回res.session\r\n获取this.$store.state.session\r\n页面获取全局函数返回的值1、原生微信小程序，比如在app.js中获取用户信息保存在 globalData 中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jsApp({\r\n  onLaunch: function() {\r\n    this.init()\r\n  },\r\n  init: function() {\r\n    // 获取用户授权结果\r\n    wx.getSetting({\r\n      success: (res) => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({ // 获取用户信息\r\n            success: res => {\r\n              this.globalData.userInfo = res.userInfo;\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            },\r\n            //拒绝授权\r\n            fail: res => {\r\n\r\n            }\r\n          })\r\n        } else {\r\n\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: \"\"\r\n  }\r\n})\r\npages/index/index.jsconst app = getApp()\r\nPage({\r\n  data: {\r\n\tuserInfo:\"\"\r\n  },\r\n  onLoad: function() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n      })\r\n    } else{\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n        })\r\n      }\r\n    } \r\n  },\r\n})\r\n2、uniapp是配合vuex和计算属性computed来处理的APP.vueexport default {\r\n\tonLaunch: function() {\r\n\t\tthis.getUserInfo();\r\n\t},\r\n\tmethods:{\r\n\t\tgetUserInfo() {\r\n\t\t\tuni.getSetting({\r\n\t\t\t  success: (res) => {\r\n\t\t\t\tif (res.authSetting['scope.userInfo']) {\r\n\t\t\t\t  uni.getUserInfo({ // 获取用户信息 \r\n\t\t\t\t\tsuccess: res => {\r\n\t\t\t\t\t\tthis.$store.commit('userInfo',{\r\n\t\t\t\t\t\t\tavatarUrl:res.userInfo.avatarUrl,\r\n\t\t\t\t\t\t\tnickName:res.userInfo.nickName\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfail: res => {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t  })\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t})\r\n\t\t},\t\r\n\t}\r\n}\r\npages/index/index.vue获取到 userInfo 便可以使用了，如果需要，还可以使用watch监听。export default {\r\n\tdata() {\r\n\t\treturn {\r\n\r\n\t\t} \r\n\t},\r\n\tonLoad(){\r\n\t\t\r\n\t},\r\n\tcomputed: {\r\n\t\tuserInfo() {\r\n\t\t\treturn this.$store.state.hasUserInfo\r\n\t\t}\r\n\t},\r\n\twatch:{\r\n\t\tuserInfo(val){\r\n\t\t\tif(val){\r\n\t \t\t \t\r\n\t \t\t}\r\n\t \t}\r\n\t},\r\n\tcreated() {\r\n\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t}\r\n}", "author": "Rolan", "pub_time": "2019-12-30 00:33", "title": "红包小程序小结 "}
